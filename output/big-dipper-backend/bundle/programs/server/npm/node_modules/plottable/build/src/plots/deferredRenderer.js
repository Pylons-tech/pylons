"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredRenderer = void 0;
/**
 * Stores the deferred transformation state for a single scale.
 */
var DomainTransform = /** @class */ (function () {
    function DomainTransform() {
        var _this = this;
        this.scale = 0;
        this.translate = 0;
        this.cachedDomain = [null, null];
        this.lastSeenDomain = [null, null];
        this.updateDomain = function (scale) {
            _this.lastSeenDomain = scale.getTransformationDomain();
            var cachedLength = scale.scaleTransformation(_this.cachedDomain[1]) - scale.scaleTransformation(_this.cachedDomain[0]);
            var lastSeenLength = scale.scaleTransformation(_this.lastSeenDomain[1]) - scale.scaleTransformation(_this.lastSeenDomain[0]);
            _this.scale = (cachedLength / lastSeenLength) || 1;
            _this.translate = scale.scaleTransformation(_this.cachedDomain[0]) - scale.scaleTransformation(_this.lastSeenDomain[0]) * _this.scale || 0;
        };
    }
    DomainTransform.prototype.reset = function () {
        this.scale = 1;
        this.translate = 0;
        this.cachedDomain = this.lastSeenDomain;
    };
    DomainTransform.prototype.setDomain = function (scale) {
        this.cachedDomain = scale.getTransformationDomain();
    };
    return DomainTransform;
}());
/**
 * Manages deferred rendering callbacks.
 *
 * Call `setDomains` when deferred rendering is initially enabled to fix the
 * current domain values.
 *
 * Call `updateDomains` when scale domains change, which uses the domain to
 * compute CSS-tyle transform parameters passed to `applyTransformCallback`,
 * mimicking the result of a full re-render. After a deferred timeout, invoke
 * `applyTransformCallback` again with an identity transform and finally invoke
 * `renderCallback`, which should actually redraw the plot.
 *
 * Call `resetTransforms` just prior to re-rendering into the canvas. This
 * ensures that the canvas is at 1:1 scaling.
 */
var DeferredRenderer = /** @class */ (function () {
    function DeferredRenderer(renderCallback, applyTransformCallback) {
        var _this = this;
        this.renderCallback = renderCallback;
        this.applyTransformCallback = applyTransformCallback;
        this.domainTransformX = new DomainTransform();
        this.domainTransformY = new DomainTransform();
        this.renderDeferred = function () {
            _this.applyTransform();
            clearTimeout(_this.timeoutToken);
            _this.timeoutToken = setTimeout(function () {
                _this.renderCallback();
            }, DeferredRenderer.DEFERRED_RENDERING_DELAY);
        };
    }
    DeferredRenderer.prototype.setDomains = function (scaleX, scaleY) {
        if (scaleX) {
            this.domainTransformX.setDomain(scaleX);
        }
        if (scaleY) {
            this.domainTransformY.setDomain(scaleY);
        }
        this.renderDeferred();
    };
    DeferredRenderer.prototype.updateDomains = function (scaleX, scaleY) {
        if (scaleX) {
            this.domainTransformX.updateDomain(scaleX);
        }
        if (scaleY) {
            this.domainTransformY.updateDomain(scaleY);
        }
        this.renderDeferred();
    };
    DeferredRenderer.prototype.resetTransforms = function () {
        this.domainTransformX.reset();
        this.domainTransformY.reset();
        this.applyTransform();
    };
    DeferredRenderer.prototype.applyTransform = function () {
        this.applyTransformCallback(this.domainTransformX.translate, this.domainTransformY.translate, this.domainTransformX.scale, this.domainTransformY.scale);
    };
    DeferredRenderer.DEFERRED_RENDERING_DELAY = 200;
    return DeferredRenderer;
}());
exports.DeferredRenderer = DeferredRenderer;
