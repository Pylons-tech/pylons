"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoizeProjectors = exports.memoizeProjector = void 0;
var memoize_1 = require("lodash-es/memoize");
/**
 * An index that stores values by numeric key.
 *
 * Internally this uses prototype-less objects as key lookups are marginally
 * faster than `{}`s.
 */
var IndexMap = /** @class */ (function () {
    function IndexMap() {
        this.map = Object.create(null);
        this.exists = Object.create(null);
    }
    IndexMap.prototype.delete = function (key) {
        delete this.map[key];
        delete this.exists[key];
        return true;
    };
    IndexMap.prototype.get = function (key) {
        return this.map[key];
    };
    IndexMap.prototype.has = function (key) {
        return !!this.exists[key];
    };
    IndexMap.prototype.set = function (key, value) {
        this.map[key] = value;
        this.exists[key] = true;
        return this;
    };
    return IndexMap;
}());
/**
 * A lodash-style `MapCache` that utilizes a [number, number] key to create a
 * fast-lookup 2D index. This is much faster than stringifying the key.
 */
var DatasetIndexCache = /** @class */ (function () {
    function DatasetIndexCache() {
        this.map = new IndexMap();
    }
    DatasetIndexCache.prototype.get = function (key) {
        return this.map.get(key[0]).get(key[1]);
    };
    DatasetIndexCache.prototype.has = function (key) {
        return this.map.has(key[0]) && this.map.get(key[0]).has(key[1]);
    };
    DatasetIndexCache.prototype.set = function (key, value) {
        this.map.has(key[0]) || this.map.set(key[0], new IndexMap());
        this.map.get(key[0]).set(key[1], value);
        return this;
    };
    DatasetIndexCache.prototype.delete = function (key) {
        // NOTE: this can potentially leave dangling `IndexMap`s if we delete
        // all the keys from the index instead of using `clear`. The overhead is
        // minimal, so this is fine.
        this.map.has(key[0]) && this.map.get(key[0]).delete(key[1]);
        return true;
    };
    DatasetIndexCache.prototype.clear = function () {
        this.map = new IndexMap();
    };
    DatasetIndexCache.resolver = function (d, i, dataset) { return [dataset.updateId(), i]; };
    return DatasetIndexCache;
}());
function memoizeProjector(projector) {
    var memo = (0, memoize_1.default)(projector, DatasetIndexCache.resolver);
    memo.cache = new DatasetIndexCache();
    return memo;
}
exports.memoizeProjector = memoizeProjector;
function memoizeProjectors(attrToProjector) {
    Object.keys(attrToProjector).forEach(function (key) {
        attrToProjector[key] = memoizeProjector(attrToProjector[key]);
    });
    return attrToProjector;
}
exports.memoizeProjectors = memoizeProjectors;
