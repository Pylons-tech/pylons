"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrappedLabel = void 0;
var tslib_1 = require("tslib");
var label_1 = require("./label");
var DEFAULT_MAX_LINES = 2;
var WrappedLabel = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(WrappedLabel, _super);
    function WrappedLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._maxLines = DEFAULT_MAX_LINES;
        return _this;
    }
    WrappedLabel.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        this._wrapper.maxLines(this._maxLines);
        var offeredLineLength = this.angle() === 0 ? offeredWidth : offeredHeight;
        if (offeredLineLength === 0) {
            offeredLineLength = Infinity;
        }
        var wrapped = this._wrapper.wrap(this._text, this._measurer, offeredLineLength);
        var measuredWrap = this._measurer.measure(wrapped.wrappedText);
        var minWidth = (this.angle() === 0 ? measuredWrap.width : measuredWrap.height) + 2 * this.padding();
        var minHeight = (this.angle() === 0 ? measuredWrap.height : measuredWrap.width) + 2 * this.padding();
        return { minWidth: minWidth, minHeight: minHeight };
    };
    WrappedLabel.prototype.maxLines = function (maxLines) {
        // allow user to un-set by passing in null or undefined explicitly
        if (arguments.length === 0) {
            return this._maxLines;
        }
        this._maxLines = maxLines;
        this.redraw();
        return this;
    };
    return WrappedLabel;
}(label_1.Label));
exports.WrappedLabel = WrappedLabel;
