"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitStrategyLinear = exports.SplitStrategyTrivial = void 0;
var SplitStrategyTrivial = /** @class */ (function () {
    function SplitStrategyTrivial() {
    }
    SplitStrategyTrivial.prototype.split = function (entries, nodes) {
        // Create simple middle split
        var mid = Math.ceil(entries.length / 2);
        for (var i = 0; i < mid; i++) {
            nodes[0].insert(entries[i]);
        }
        for (var i = mid; i < entries.length; i++) {
            nodes[1].insert(entries[i]);
        }
    };
    return SplitStrategyTrivial;
}());
exports.SplitStrategyTrivial = SplitStrategyTrivial;
// Linear split method adapted from https://github.com/imbcmdth/RTree/blob/master/src/rtree.js
var SplitStrategyLinear = /** @class */ (function () {
    function SplitStrategyLinear() {
    }
    SplitStrategyLinear.prototype.split = function (entries, nodes) {
        // copy entries before we mutate it
        entries = entries.slice();
        this.chooseFirstSplit(entries, nodes);
        while (entries.length > 0) {
            this.addNext(entries, nodes);
        }
    };
    /**
     * Choose the two farthest-apart entries to begin the split.
     */
    SplitStrategyLinear.prototype.chooseFirstSplit = function (entries, nodes) {
        // Determine entry indices that have min/max x/y coordinates
        var minXH = 0;
        var minYH = 0;
        var maxXL = entries.length - 1;
        var maxYL = entries.length - 1;
        for (var i = 1; i < entries.length - 1; i++) {
            var entry = entries[i];
            if (entry.bounds.xl > entries[maxXL].bounds.xl) {
                maxXL = i;
            }
            else if (entry.bounds.xh < entries[minXH].bounds.xh) {
                minXH = i;
            }
            if (entry.bounds.yl > entries[maxYL].bounds.yl) {
                maxYL = i;
            }
            else if (entry.bounds.yh < entries[minYH].bounds.yh) {
                minYH = i;
            }
        }
        // Choose to split x or y based on greatest difference
        var dx = Math.abs(entries[minXH].bounds.xh - entries[maxXL].bounds.xl);
        var dy = Math.abs(entries[minYH].bounds.yh - entries[maxYL].bounds.yl);
        var _a = dx > dy ? [minXH, maxXL] : [minYH, maxYL], i0 = _a[0], i1 = _a[1];
        // if no detectable split, just use first/last entries
        if (i0 === i1) {
            i0 = 0;
            i1 = entries.length - 1;
        }
        // Split off nodes. We splice with the max index first to make sure we
        // don't change the index of the second splice call
        nodes[0].insert(entries.splice(Math.max(i0, i1), 1)[0]);
        nodes[1].insert(entries.splice(Math.min(i0, i1), 1)[0]);
    };
    /**
     * Split the next entry. Choose the entry that expands its parent node's
     * area the least.
     */
    SplitStrategyLinear.prototype.addNext = function (entries, nodes) {
        var index = null;
        var minDiff = null;
        var minDiffNode = null;
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            var areaDiff0 = nodes[0].unionAreaDifference(entry.bounds);
            var areaDiff1 = nodes[1].unionAreaDifference(entry.bounds);
            if (areaDiff0 < minDiff || index == null) {
                index = i;
                minDiff = areaDiff0;
                minDiffNode = nodes[0];
            }
            if (areaDiff1 < minDiff) {
                index = i;
                minDiff = areaDiff1;
                minDiffNode = nodes[1];
            }
        }
        minDiffNode.insert(entries.splice(index, 1)[0]);
    };
    return SplitStrategyLinear;
}());
exports.SplitStrategyLinear = SplitStrategyLinear;
