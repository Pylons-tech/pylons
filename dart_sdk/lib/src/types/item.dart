import 'package:fixnum/fixnum.dart';
import 'package:pylons_sdk/pylons_sdk.dart';

import '../generated/pylons/execution.pb.dart' as generated;
import '../generated/pylons/item.pb.dart' as generated;

/// Wrapper object for an item.
/// These can be retrieved from a number of queries and operations,
/// and are considered either 'complete' or 'partial.'
/// Certain data is not available from partial items, and if those fields
/// are needed, you have to call Item.get() with the ID from the partial item.
class Item {
  final generated.Item? _native;
  // if from itemrecord: missing a bunch of fields, keep that in mind
  final generated.ItemRecord? _nativeRecord;
  final bool _complete;

  /// Is this a partial item?
  bool get partial => !_complete;

  Item(this._native, this._nativeRecord, this._complete);

  Item.fromItem(generated.Item n)
      : _native = n,
        _nativeRecord = null,
        _complete = true;
  Item.fromRecord(generated.ItemRecord n)
      : _native = null,
        _nativeRecord = n,
        _complete = false;

  /// Retrieves the item with the provided ID from the chain.
  /// If cookbook is specified manually, you can override the loaded cookbook
  /// or query an item before loading a cookbook; otherwise, the item
  /// will be retrieved for the loaded cookbook.
  static Future<Item> get(String id, {String? cookbook}) async {
    if (cookbook == null) {
      if (Cookbook.current == null) {
        throw Exception('Load a cookbook before calling Item.get');
      }
      cookbook = Cookbook.current!.getId();
    }
    var ll = await PylonsWallet.instance
        .getItemById(cookbookId: cookbook, itemId: id);
    if (ll.success) {
      return Item.fromItem(ll.data!);
    } else {
      return Future.error(ll.error);
    }
  }

  /// Re-retrieves an item from the chain.
  Future<Item> refresh () async {
    return get(getId(), cookbook : getCookbookId());
  }

  /// Retrieves the ID of the item's associated cookbook.
  ///
  /// Not available on partial items.
  String getCookbookId() {
    if (_complete) {
      return _native!.cookbookId;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the item's ID.
  String getId() {
    if (_complete) {
      return _native!.id;
    } else {
      return _nativeRecord!.id;
    }
  }

  /// Retrieves the ID of the recipe the item was generated by.
  ///
  /// Not available on partial items.
  String getRecipeId() {
    if (_complete) {
      return _native!.recipeId;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the address of the item's owner.
  ///
  /// Not available on partial items.
  String getOwner() {
    if (_complete) {
      return _native!.owner;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Can the item be transferred to other users?
  ///
  /// Not available on partial items.
  bool isTradeable() {
    if (_complete) {
      return _native!.tradeable;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// To be documented; not generally significant to client applications.
  ///
  /// Not available on partial items.
  double getTradePercentage() {
    if (_complete) {
      // TODO: check if this is right
      return double.parse(_native!.tradePercentage);
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the block height as of this item's last update.
  ///
  /// Not available on partial items.
  Int64 getLastUpdate() {
    if (_complete) {
      // TODO: all of these should have some functionality to turn this into a datetime.
      // block height is godawful. encapsulating this sort of data in something useful
      // should be the big upside of hiding the generated types like this.
      // but that's all contingent on being able to get a real date/time from block height
      // somehow...
      return _native!.lastUpdate;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the block height as of this item's creation.
  ///
  /// Not available on partial items.
  Int64 getCreatedAt() {
    if (_complete) {
      return _native!.createdAt;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// TODO: what even is the difference between this and lastUpdate
  Int64 getUpdatedAt() {
    if (_complete) {
      return _native!.updatedAt;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the node version of this item.
  /// Since all items are retrieved from the chain,
  /// this should generally just be the current version;
  /// don't worry about it.
  ///
  /// Not available on partial items.
  Int64 getNodeVersion() {
    if (_complete) {
      return _native!.nodeVersion;
    } else {
      throw UnsupportedError(
          'Cannot retrieve this field from ItemRecord - call Item.get() with the provided ID if needed');
    }
  }

  /// Retrieves the double parameter with the provided key for this item,
  /// or null if no such parameter exists.
  double? getDouble(String key) {
    var found;
    try {
      if (_complete) {
        found =
            _native!.doubles.firstWhere((element) => element.key == key).value;
      } else {
        found = _nativeRecord!.doubles
            .firstWhere((element) => element.key == key)
            .value;
      }
    } on StateError {
      found = null;
    }
    return found;
  }

  /// Retrieves the Int64 parameter with the provided key for this item,
  /// or null if no such parameter exists.
  Int64? getInt(String key) {
    var found;
    try {
      if (_complete) {
        found =
            _native!.longs.firstWhere((element) => element.key == key).value;
      } else {
        found = _nativeRecord!.longs
            .firstWhere((element) => element.key == key)
            .value;
      }
    } on StateError {
      found = null;
    }
    return found;
  }

  /// Retrieves the string parameter with the provided key for this item,
  /// or null if no such parameter exists.
  String? getString(String key) {
    var found;
    try {
      if (_complete) {
        found =
            _native!.strings.firstWhere((element) => element.key == key).value;
      } else {
        found = _nativeRecord!.strings
            .firstWhere((element) => element.key == key)
            .value;
      }
    } on StateError {
      found = null;
    }
    if (found == null) {
      try {
        if (_complete) {
          found = _native!.mutableStrings
              .firstWhere((element) => element.key == key)
              .value;
        }
      } on StateError {
        // swallow, it's already null
      }
    }
    return found;
  }
}
