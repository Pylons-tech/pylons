// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pylons/query.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AddrFromPubKeyRequest struct {
	HexPubKey string `protobuf:"bytes,1,opt,name=hex_pub_key,json=hexPubKey,proto3" json:"hex_pub_key,omitempty"`
}

func (m *AddrFromPubKeyRequest) Reset()         { *m = AddrFromPubKeyRequest{} }
func (m *AddrFromPubKeyRequest) String() string { return proto.CompactTextString(m) }
func (*AddrFromPubKeyRequest) ProtoMessage()    {}
func (*AddrFromPubKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{0}
}
func (m *AddrFromPubKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddrFromPubKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddrFromPubKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddrFromPubKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrFromPubKeyRequest.Merge(m, src)
}
func (m *AddrFromPubKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddrFromPubKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrFromPubKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddrFromPubKeyRequest proto.InternalMessageInfo

func (m *AddrFromPubKeyRequest) GetHexPubKey() string {
	if m != nil {
		return m.HexPubKey
	}
	return ""
}

type AddrFromPubKeyResponse struct {
	Bech32Addr string `protobuf:"bytes,1,opt,name=Bech32Addr,proto3" json:"Bech32Addr,omitempty"`
}

func (m *AddrFromPubKeyResponse) Reset()         { *m = AddrFromPubKeyResponse{} }
func (m *AddrFromPubKeyResponse) String() string { return proto.CompactTextString(m) }
func (*AddrFromPubKeyResponse) ProtoMessage()    {}
func (*AddrFromPubKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{1}
}
func (m *AddrFromPubKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddrFromPubKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddrFromPubKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddrFromPubKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrFromPubKeyResponse.Merge(m, src)
}
func (m *AddrFromPubKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddrFromPubKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrFromPubKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddrFromPubKeyResponse proto.InternalMessageInfo

func (m *AddrFromPubKeyResponse) GetBech32Addr() string {
	if m != nil {
		return m.Bech32Addr
	}
	return ""
}

type CheckGoogleIAPOrderRequest struct {
	PurchaseToken string `protobuf:"bytes,1,opt,name=purchaseToken,proto3" json:"purchaseToken,omitempty"`
}

func (m *CheckGoogleIAPOrderRequest) Reset()         { *m = CheckGoogleIAPOrderRequest{} }
func (m *CheckGoogleIAPOrderRequest) String() string { return proto.CompactTextString(m) }
func (*CheckGoogleIAPOrderRequest) ProtoMessage()    {}
func (*CheckGoogleIAPOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{2}
}
func (m *CheckGoogleIAPOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckGoogleIAPOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckGoogleIAPOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckGoogleIAPOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckGoogleIAPOrderRequest.Merge(m, src)
}
func (m *CheckGoogleIAPOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckGoogleIAPOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckGoogleIAPOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckGoogleIAPOrderRequest proto.InternalMessageInfo

func (m *CheckGoogleIAPOrderRequest) GetPurchaseToken() string {
	if m != nil {
		return m.PurchaseToken
	}
	return ""
}

type CheckGoogleIAPOrderResponse struct {
	PurchaseToken string `protobuf:"bytes,1,opt,name=purchaseToken,proto3" json:"purchaseToken,omitempty"`
	Exist         bool   `protobuf:"varint,2,opt,name=exist,proto3" json:"exist,omitempty"`
}

func (m *CheckGoogleIAPOrderResponse) Reset()         { *m = CheckGoogleIAPOrderResponse{} }
func (m *CheckGoogleIAPOrderResponse) String() string { return proto.CompactTextString(m) }
func (*CheckGoogleIAPOrderResponse) ProtoMessage()    {}
func (*CheckGoogleIAPOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{3}
}
func (m *CheckGoogleIAPOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckGoogleIAPOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckGoogleIAPOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckGoogleIAPOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckGoogleIAPOrderResponse.Merge(m, src)
}
func (m *CheckGoogleIAPOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckGoogleIAPOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckGoogleIAPOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckGoogleIAPOrderResponse proto.InternalMessageInfo

func (m *CheckGoogleIAPOrderResponse) GetPurchaseToken() string {
	if m != nil {
		return m.PurchaseToken
	}
	return ""
}

func (m *CheckGoogleIAPOrderResponse) GetExist() bool {
	if m != nil {
		return m.Exist
	}
	return false
}

type GetCookbookRequest struct {
	CookbookID string `protobuf:"bytes,1,opt,name=cookbookID,proto3" json:"cookbookID,omitempty"`
}

func (m *GetCookbookRequest) Reset()         { *m = GetCookbookRequest{} }
func (m *GetCookbookRequest) String() string { return proto.CompactTextString(m) }
func (*GetCookbookRequest) ProtoMessage()    {}
func (*GetCookbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{4}
}
func (m *GetCookbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCookbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCookbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCookbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCookbookRequest.Merge(m, src)
}
func (m *GetCookbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCookbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCookbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCookbookRequest proto.InternalMessageInfo

func (m *GetCookbookRequest) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

type GetCookbookResponse struct {
	NodeVersion  string `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID           string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Name         string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Description  string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      string `protobuf:"bytes,5,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string `protobuf:"bytes,6,opt,name=Developer,proto3" json:"Developer,omitempty"`
	Level        int64  `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
	SupportEmail string `protobuf:"bytes,8,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	CostPerBlock int64  `protobuf:"varint,9,opt,name=CostPerBlock,proto3" json:"CostPerBlock,omitempty"`
	Sender       string `protobuf:"bytes,10,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *GetCookbookResponse) Reset()         { *m = GetCookbookResponse{} }
func (m *GetCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*GetCookbookResponse) ProtoMessage()    {}
func (*GetCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{5}
}
func (m *GetCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCookbookResponse.Merge(m, src)
}
func (m *GetCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCookbookResponse proto.InternalMessageInfo

func (m *GetCookbookResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *GetCookbookResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetCookbookResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetCookbookResponse) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GetCookbookResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetCookbookResponse) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *GetCookbookResponse) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GetCookbookResponse) GetSupportEmail() string {
	if m != nil {
		return m.SupportEmail
	}
	return ""
}

func (m *GetCookbookResponse) GetCostPerBlock() int64 {
	if m != nil {
		return m.CostPerBlock
	}
	return 0
}

func (m *GetCookbookResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type GetExecutionRequest struct {
	ExecutionID string `protobuf:"bytes,1,opt,name=executionID,proto3" json:"executionID,omitempty"`
}

func (m *GetExecutionRequest) Reset()         { *m = GetExecutionRequest{} }
func (m *GetExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*GetExecutionRequest) ProtoMessage()    {}
func (*GetExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{6}
}
func (m *GetExecutionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetExecutionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetExecutionRequest.Merge(m, src)
}
func (m *GetExecutionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetExecutionRequest proto.InternalMessageInfo

func (m *GetExecutionRequest) GetExecutionID() string {
	if m != nil {
		return m.ExecutionID
	}
	return ""
}

type GetExecutionResponse struct {
	NodeVersion string                                   `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID          string                                   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	RecipeID    string                                   `protobuf:"bytes,3,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	CookbookID  string                                   `protobuf:"bytes,4,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	CoinsInput  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=CoinsInput,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinsInput"`
	ItemInputs  []Item                                   `protobuf:"bytes,6,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	BlockHeight int64                                    `protobuf:"varint,7,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Sender      string                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Completed   bool                                     `protobuf:"varint,9,opt,name=Completed,proto3" json:"Completed,omitempty"`
}

func (m *GetExecutionResponse) Reset()         { *m = GetExecutionResponse{} }
func (m *GetExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*GetExecutionResponse) ProtoMessage()    {}
func (*GetExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{7}
}
func (m *GetExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetExecutionResponse.Merge(m, src)
}
func (m *GetExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetExecutionResponse proto.InternalMessageInfo

func (m *GetExecutionResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *GetExecutionResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetExecutionResponse) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *GetExecutionResponse) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *GetExecutionResponse) GetCoinsInput() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinsInput
	}
	return nil
}

func (m *GetExecutionResponse) GetItemInputs() []Item {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *GetExecutionResponse) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *GetExecutionResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *GetExecutionResponse) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

type GetItemRequest struct {
	ItemID string `protobuf:"bytes,1,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *GetItemRequest) Reset()         { *m = GetItemRequest{} }
func (m *GetItemRequest) String() string { return proto.CompactTextString(m) }
func (*GetItemRequest) ProtoMessage()    {}
func (*GetItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{8}
}
func (m *GetItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemRequest.Merge(m, src)
}
func (m *GetItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemRequest proto.InternalMessageInfo

func (m *GetItemRequest) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

type GetItemResponse struct {
	Item Item `protobuf:"bytes,1,opt,name=item,proto3" json:"item"`
}

func (m *GetItemResponse) Reset()         { *m = GetItemResponse{} }
func (m *GetItemResponse) String() string { return proto.CompactTextString(m) }
func (*GetItemResponse) ProtoMessage()    {}
func (*GetItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{9}
}
func (m *GetItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemResponse.Merge(m, src)
}
func (m *GetItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemResponse proto.InternalMessageInfo

func (m *GetItemResponse) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type GetRecipeRequest struct {
	RecipeID string `protobuf:"bytes,1,opt,name=recipeID,proto3" json:"recipeID,omitempty"`
}

func (m *GetRecipeRequest) Reset()         { *m = GetRecipeRequest{} }
func (m *GetRecipeRequest) String() string { return proto.CompactTextString(m) }
func (*GetRecipeRequest) ProtoMessage()    {}
func (*GetRecipeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{10}
}
func (m *GetRecipeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRecipeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRecipeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRecipeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRecipeRequest.Merge(m, src)
}
func (m *GetRecipeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRecipeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRecipeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRecipeRequest proto.InternalMessageInfo

func (m *GetRecipeRequest) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

type GetRecipeResponse struct {
	NodeVersion   string            `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID            string            `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	CookbookID    string            `protobuf:"bytes,3,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Name          string            `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	CoinInputs    []CoinInput       `protobuf:"bytes,5,rep,name=CoinInputs,proto3" json:"CoinInputs"`
	ItemInputs    []ItemInput       `protobuf:"bytes,6,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	Entries       EntriesList       `protobuf:"bytes,7,opt,name=Entries,proto3" json:"Entries"`
	Outputs       []WeightedOutputs `protobuf:"bytes,8,rep,name=Outputs,proto3" json:"Outputs"`
	Description   string            `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	BlockInterval int64             `protobuf:"varint,10,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string            `protobuf:"bytes,11,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Disabled      bool              `protobuf:"varint,12,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
}

func (m *GetRecipeResponse) Reset()         { *m = GetRecipeResponse{} }
func (m *GetRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*GetRecipeResponse) ProtoMessage()    {}
func (*GetRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{11}
}
func (m *GetRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRecipeResponse.Merge(m, src)
}
func (m *GetRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRecipeResponse proto.InternalMessageInfo

func (m *GetRecipeResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *GetRecipeResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetRecipeResponse) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *GetRecipeResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetRecipeResponse) GetCoinInputs() []CoinInput {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *GetRecipeResponse) GetItemInputs() []ItemInput {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *GetRecipeResponse) GetEntries() EntriesList {
	if m != nil {
		return m.Entries
	}
	return EntriesList{}
}

func (m *GetRecipeResponse) GetOutputs() []WeightedOutputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *GetRecipeResponse) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GetRecipeResponse) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *GetRecipeResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *GetRecipeResponse) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

type GetTradeRequest struct {
	TradeID string `protobuf:"bytes,1,opt,name=tradeID,proto3" json:"tradeID,omitempty"`
}

func (m *GetTradeRequest) Reset()         { *m = GetTradeRequest{} }
func (m *GetTradeRequest) String() string { return proto.CompactTextString(m) }
func (*GetTradeRequest) ProtoMessage()    {}
func (*GetTradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{12}
}
func (m *GetTradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTradeRequest.Merge(m, src)
}
func (m *GetTradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTradeRequest proto.InternalMessageInfo

func (m *GetTradeRequest) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

type GetTradeResponse struct {
	NodeVersion string                                   `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID          string                                   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	CoinInputs  []CoinInput                              `protobuf:"bytes,3,rep,name=CoinInputs,proto3" json:"CoinInputs"`
	ItemInputs  []TradeItemInput                         `protobuf:"bytes,4,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	CoinOutputs github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=CoinOutputs,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinOutputs"`
	ItemOutputs []Item                                   `protobuf:"bytes,6,rep,name=ItemOutputs,proto3" json:"ItemOutputs"`
	ExtraInfo   string                                   `protobuf:"bytes,7,opt,name=ExtraInfo,proto3" json:"ExtraInfo,omitempty"`
	Sender      string                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	FulFiller   string                                   `protobuf:"bytes,9,opt,name=FulFiller,proto3" json:"FulFiller,omitempty"`
	Disabled    bool                                     `protobuf:"varint,10,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
	Completed   bool                                     `protobuf:"varint,11,opt,name=Completed,proto3" json:"Completed,omitempty"`
}

func (m *GetTradeResponse) Reset()         { *m = GetTradeResponse{} }
func (m *GetTradeResponse) String() string { return proto.CompactTextString(m) }
func (*GetTradeResponse) ProtoMessage()    {}
func (*GetTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{13}
}
func (m *GetTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTradeResponse.Merge(m, src)
}
func (m *GetTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTradeResponse proto.InternalMessageInfo

func (m *GetTradeResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *GetTradeResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetTradeResponse) GetCoinInputs() []CoinInput {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *GetTradeResponse) GetItemInputs() []TradeItemInput {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *GetTradeResponse) GetCoinOutputs() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinOutputs
	}
	return nil
}

func (m *GetTradeResponse) GetItemOutputs() []Item {
	if m != nil {
		return m.ItemOutputs
	}
	return nil
}

func (m *GetTradeResponse) GetExtraInfo() string {
	if m != nil {
		return m.ExtraInfo
	}
	return ""
}

func (m *GetTradeResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *GetTradeResponse) GetFulFiller() string {
	if m != nil {
		return m.FulFiller
	}
	return ""
}

func (m *GetTradeResponse) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *GetTradeResponse) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

type ItemsByCookbookRequest struct {
	CookbookID string `protobuf:"bytes,1,opt,name=cookbookID,proto3" json:"cookbookID,omitempty"`
}

func (m *ItemsByCookbookRequest) Reset()         { *m = ItemsByCookbookRequest{} }
func (m *ItemsByCookbookRequest) String() string { return proto.CompactTextString(m) }
func (*ItemsByCookbookRequest) ProtoMessage()    {}
func (*ItemsByCookbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{14}
}
func (m *ItemsByCookbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsByCookbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsByCookbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsByCookbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsByCookbookRequest.Merge(m, src)
}
func (m *ItemsByCookbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ItemsByCookbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsByCookbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsByCookbookRequest proto.InternalMessageInfo

func (m *ItemsByCookbookRequest) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

type ItemsByCookbookResponse struct {
	Items []Item `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items"`
}

func (m *ItemsByCookbookResponse) Reset()         { *m = ItemsByCookbookResponse{} }
func (m *ItemsByCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*ItemsByCookbookResponse) ProtoMessage()    {}
func (*ItemsByCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{15}
}
func (m *ItemsByCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsByCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsByCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsByCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsByCookbookResponse.Merge(m, src)
}
func (m *ItemsByCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *ItemsByCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsByCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsByCookbookResponse proto.InternalMessageInfo

func (m *ItemsByCookbookResponse) GetItems() []Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ItemsBySenderRequest struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *ItemsBySenderRequest) Reset()         { *m = ItemsBySenderRequest{} }
func (m *ItemsBySenderRequest) String() string { return proto.CompactTextString(m) }
func (*ItemsBySenderRequest) ProtoMessage()    {}
func (*ItemsBySenderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{16}
}
func (m *ItemsBySenderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsBySenderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsBySenderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsBySenderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsBySenderRequest.Merge(m, src)
}
func (m *ItemsBySenderRequest) XXX_Size() int {
	return m.Size()
}
func (m *ItemsBySenderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsBySenderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsBySenderRequest proto.InternalMessageInfo

func (m *ItemsBySenderRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type ItemsBySenderResponse struct {
	Items []Item `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items"`
}

func (m *ItemsBySenderResponse) Reset()         { *m = ItemsBySenderResponse{} }
func (m *ItemsBySenderResponse) String() string { return proto.CompactTextString(m) }
func (*ItemsBySenderResponse) ProtoMessage()    {}
func (*ItemsBySenderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{17}
}
func (m *ItemsBySenderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemsBySenderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemsBySenderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemsBySenderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemsBySenderResponse.Merge(m, src)
}
func (m *ItemsBySenderResponse) XXX_Size() int {
	return m.Size()
}
func (m *ItemsBySenderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemsBySenderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ItemsBySenderResponse proto.InternalMessageInfo

func (m *ItemsBySenderResponse) GetItems() []Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ListCookbookRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ListCookbookRequest) Reset()         { *m = ListCookbookRequest{} }
func (m *ListCookbookRequest) String() string { return proto.CompactTextString(m) }
func (*ListCookbookRequest) ProtoMessage()    {}
func (*ListCookbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{18}
}
func (m *ListCookbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCookbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCookbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCookbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCookbookRequest.Merge(m, src)
}
func (m *ListCookbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCookbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCookbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCookbookRequest proto.InternalMessageInfo

func (m *ListCookbookRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ListCookbookResponse struct {
	Cookbooks []Cookbook `protobuf:"bytes,1,rep,name=Cookbooks,proto3" json:"Cookbooks"`
}

func (m *ListCookbookResponse) Reset()         { *m = ListCookbookResponse{} }
func (m *ListCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*ListCookbookResponse) ProtoMessage()    {}
func (*ListCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{19}
}
func (m *ListCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCookbookResponse.Merge(m, src)
}
func (m *ListCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListCookbookResponse proto.InternalMessageInfo

func (m *ListCookbookResponse) GetCookbooks() []Cookbook {
	if m != nil {
		return m.Cookbooks
	}
	return nil
}

type ListExecutionsRequest struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *ListExecutionsRequest) Reset()         { *m = ListExecutionsRequest{} }
func (m *ListExecutionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListExecutionsRequest) ProtoMessage()    {}
func (*ListExecutionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{20}
}
func (m *ListExecutionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExecutionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExecutionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListExecutionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExecutionsRequest.Merge(m, src)
}
func (m *ListExecutionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListExecutionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExecutionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListExecutionsRequest proto.InternalMessageInfo

func (m *ListExecutionsRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type ListExecutionsResponse struct {
	Executions []Execution `protobuf:"bytes,1,rep,name=Executions,proto3" json:"Executions"`
}

func (m *ListExecutionsResponse) Reset()         { *m = ListExecutionsResponse{} }
func (m *ListExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListExecutionsResponse) ProtoMessage()    {}
func (*ListExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{21}
}
func (m *ListExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExecutionsResponse.Merge(m, src)
}
func (m *ListExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListExecutionsResponse proto.InternalMessageInfo

func (m *ListExecutionsResponse) GetExecutions() []Execution {
	if m != nil {
		return m.Executions
	}
	return nil
}

type GetLockedCoinsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GetLockedCoinsRequest) Reset()         { *m = GetLockedCoinsRequest{} }
func (m *GetLockedCoinsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLockedCoinsRequest) ProtoMessage()    {}
func (*GetLockedCoinsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{22}
}
func (m *GetLockedCoinsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLockedCoinsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLockedCoinsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLockedCoinsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLockedCoinsRequest.Merge(m, src)
}
func (m *GetLockedCoinsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLockedCoinsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLockedCoinsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLockedCoinsRequest proto.InternalMessageInfo

func (m *GetLockedCoinsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetLockedCoinsResponse struct {
	NodeVersion string                                   `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	Sender      string                                   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Amount      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
}

func (m *GetLockedCoinsResponse) Reset()         { *m = GetLockedCoinsResponse{} }
func (m *GetLockedCoinsResponse) String() string { return proto.CompactTextString(m) }
func (*GetLockedCoinsResponse) ProtoMessage()    {}
func (*GetLockedCoinsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{23}
}
func (m *GetLockedCoinsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLockedCoinsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLockedCoinsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLockedCoinsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLockedCoinsResponse.Merge(m, src)
}
func (m *GetLockedCoinsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLockedCoinsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLockedCoinsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLockedCoinsResponse proto.InternalMessageInfo

func (m *GetLockedCoinsResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *GetLockedCoinsResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *GetLockedCoinsResponse) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

type GetLockedCoinDetailsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GetLockedCoinDetailsRequest) Reset()         { *m = GetLockedCoinDetailsRequest{} }
func (m *GetLockedCoinDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLockedCoinDetailsRequest) ProtoMessage()    {}
func (*GetLockedCoinDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{24}
}
func (m *GetLockedCoinDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLockedCoinDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLockedCoinDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLockedCoinDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLockedCoinDetailsRequest.Merge(m, src)
}
func (m *GetLockedCoinDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLockedCoinDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLockedCoinDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLockedCoinDetailsRequest proto.InternalMessageInfo

func (m *GetLockedCoinDetailsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetLockedCoinDetailsResponse struct {
	Sender         string                                   `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Amount         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
	LockCoinTrades []LockedCoinDescribe                     `protobuf:"bytes,3,rep,name=LockCoinTrades,proto3" json:"LockCoinTrades"`
	LockCoinExecs  []LockedCoinDescribe                     `protobuf:"bytes,4,rep,name=LockCoinExecs,proto3" json:"LockCoinExecs"`
}

func (m *GetLockedCoinDetailsResponse) Reset()         { *m = GetLockedCoinDetailsResponse{} }
func (m *GetLockedCoinDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetLockedCoinDetailsResponse) ProtoMessage()    {}
func (*GetLockedCoinDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{25}
}
func (m *GetLockedCoinDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLockedCoinDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLockedCoinDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLockedCoinDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLockedCoinDetailsResponse.Merge(m, src)
}
func (m *GetLockedCoinDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLockedCoinDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLockedCoinDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLockedCoinDetailsResponse proto.InternalMessageInfo

func (m *GetLockedCoinDetailsResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *GetLockedCoinDetailsResponse) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *GetLockedCoinDetailsResponse) GetLockCoinTrades() []LockedCoinDescribe {
	if m != nil {
		return m.LockCoinTrades
	}
	return nil
}

func (m *GetLockedCoinDetailsResponse) GetLockCoinExecs() []LockedCoinDescribe {
	if m != nil {
		return m.LockCoinExecs
	}
	return nil
}

type ListRecipeRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ListRecipeRequest) Reset()         { *m = ListRecipeRequest{} }
func (m *ListRecipeRequest) String() string { return proto.CompactTextString(m) }
func (*ListRecipeRequest) ProtoMessage()    {}
func (*ListRecipeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{26}
}
func (m *ListRecipeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRecipeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRecipeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRecipeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRecipeRequest.Merge(m, src)
}
func (m *ListRecipeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRecipeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRecipeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRecipeRequest proto.InternalMessageInfo

func (m *ListRecipeRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ListRecipeResponse struct {
	Recipes []Recipe `protobuf:"bytes,1,rep,name=recipes,proto3" json:"recipes"`
}

func (m *ListRecipeResponse) Reset()         { *m = ListRecipeResponse{} }
func (m *ListRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*ListRecipeResponse) ProtoMessage()    {}
func (*ListRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{27}
}
func (m *ListRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRecipeResponse.Merge(m, src)
}
func (m *ListRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRecipeResponse proto.InternalMessageInfo

func (m *ListRecipeResponse) GetRecipes() []Recipe {
	if m != nil {
		return m.Recipes
	}
	return nil
}

type ListRecipeByCookbookRequest struct {
	CookbookID string `protobuf:"bytes,1,opt,name=cookbookID,proto3" json:"cookbookID,omitempty"`
}

func (m *ListRecipeByCookbookRequest) Reset()         { *m = ListRecipeByCookbookRequest{} }
func (m *ListRecipeByCookbookRequest) String() string { return proto.CompactTextString(m) }
func (*ListRecipeByCookbookRequest) ProtoMessage()    {}
func (*ListRecipeByCookbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{28}
}
func (m *ListRecipeByCookbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRecipeByCookbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRecipeByCookbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRecipeByCookbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRecipeByCookbookRequest.Merge(m, src)
}
func (m *ListRecipeByCookbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRecipeByCookbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRecipeByCookbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRecipeByCookbookRequest proto.InternalMessageInfo

func (m *ListRecipeByCookbookRequest) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

type ListRecipeByCookbookResponse struct {
	Recipes []Recipe `protobuf:"bytes,1,rep,name=recipes,proto3" json:"recipes"`
}

func (m *ListRecipeByCookbookResponse) Reset()         { *m = ListRecipeByCookbookResponse{} }
func (m *ListRecipeByCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*ListRecipeByCookbookResponse) ProtoMessage()    {}
func (*ListRecipeByCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{29}
}
func (m *ListRecipeByCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRecipeByCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRecipeByCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRecipeByCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRecipeByCookbookResponse.Merge(m, src)
}
func (m *ListRecipeByCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRecipeByCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRecipeByCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRecipeByCookbookResponse proto.InternalMessageInfo

func (m *ListRecipeByCookbookResponse) GetRecipes() []Recipe {
	if m != nil {
		return m.Recipes
	}
	return nil
}

type ListShortenRecipeRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ListShortenRecipeRequest) Reset()         { *m = ListShortenRecipeRequest{} }
func (m *ListShortenRecipeRequest) String() string { return proto.CompactTextString(m) }
func (*ListShortenRecipeRequest) ProtoMessage()    {}
func (*ListShortenRecipeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{30}
}
func (m *ListShortenRecipeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShortenRecipeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShortenRecipeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShortenRecipeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShortenRecipeRequest.Merge(m, src)
}
func (m *ListShortenRecipeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListShortenRecipeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShortenRecipeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListShortenRecipeRequest proto.InternalMessageInfo

func (m *ListShortenRecipeRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ListShortenRecipeResponse struct {
	Recipes []ShortenRecipe `protobuf:"bytes,1,rep,name=recipes,proto3" json:"recipes"`
}

func (m *ListShortenRecipeResponse) Reset()         { *m = ListShortenRecipeResponse{} }
func (m *ListShortenRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*ListShortenRecipeResponse) ProtoMessage()    {}
func (*ListShortenRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{31}
}
func (m *ListShortenRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShortenRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShortenRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShortenRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShortenRecipeResponse.Merge(m, src)
}
func (m *ListShortenRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListShortenRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShortenRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListShortenRecipeResponse proto.InternalMessageInfo

func (m *ListShortenRecipeResponse) GetRecipes() []ShortenRecipe {
	if m != nil {
		return m.Recipes
	}
	return nil
}

type ListShortenRecipeByCookbookRequest struct {
	CookbookID string `protobuf:"bytes,1,opt,name=cookbookID,proto3" json:"cookbookID,omitempty"`
}

func (m *ListShortenRecipeByCookbookRequest) Reset()         { *m = ListShortenRecipeByCookbookRequest{} }
func (m *ListShortenRecipeByCookbookRequest) String() string { return proto.CompactTextString(m) }
func (*ListShortenRecipeByCookbookRequest) ProtoMessage()    {}
func (*ListShortenRecipeByCookbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{32}
}
func (m *ListShortenRecipeByCookbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShortenRecipeByCookbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShortenRecipeByCookbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShortenRecipeByCookbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShortenRecipeByCookbookRequest.Merge(m, src)
}
func (m *ListShortenRecipeByCookbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListShortenRecipeByCookbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShortenRecipeByCookbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListShortenRecipeByCookbookRequest proto.InternalMessageInfo

func (m *ListShortenRecipeByCookbookRequest) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

type ListShortenRecipeByCookbookResponse struct {
	Recipes []ShortenRecipe `protobuf:"bytes,1,rep,name=recipes,proto3" json:"recipes"`
}

func (m *ListShortenRecipeByCookbookResponse) Reset()         { *m = ListShortenRecipeByCookbookResponse{} }
func (m *ListShortenRecipeByCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*ListShortenRecipeByCookbookResponse) ProtoMessage()    {}
func (*ListShortenRecipeByCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{33}
}
func (m *ListShortenRecipeByCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShortenRecipeByCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShortenRecipeByCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShortenRecipeByCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShortenRecipeByCookbookResponse.Merge(m, src)
}
func (m *ListShortenRecipeByCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListShortenRecipeByCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShortenRecipeByCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListShortenRecipeByCookbookResponse proto.InternalMessageInfo

func (m *ListShortenRecipeByCookbookResponse) GetRecipes() []ShortenRecipe {
	if m != nil {
		return m.Recipes
	}
	return nil
}

type ListTradeRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ListTradeRequest) Reset()         { *m = ListTradeRequest{} }
func (m *ListTradeRequest) String() string { return proto.CompactTextString(m) }
func (*ListTradeRequest) ProtoMessage()    {}
func (*ListTradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{34}
}
func (m *ListTradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTradeRequest.Merge(m, src)
}
func (m *ListTradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTradeRequest proto.InternalMessageInfo

func (m *ListTradeRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ListTradeResponse struct {
	Trades []Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades"`
}

func (m *ListTradeResponse) Reset()         { *m = ListTradeResponse{} }
func (m *ListTradeResponse) String() string { return proto.CompactTextString(m) }
func (*ListTradeResponse) ProtoMessage()    {}
func (*ListTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{35}
}
func (m *ListTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTradeResponse.Merge(m, src)
}
func (m *ListTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTradeResponse proto.InternalMessageInfo

func (m *ListTradeResponse) GetTrades() []Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

type PylonsBalanceRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *PylonsBalanceRequest) Reset()         { *m = PylonsBalanceRequest{} }
func (m *PylonsBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*PylonsBalanceRequest) ProtoMessage()    {}
func (*PylonsBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{36}
}
func (m *PylonsBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PylonsBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PylonsBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PylonsBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PylonsBalanceRequest.Merge(m, src)
}
func (m *PylonsBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *PylonsBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PylonsBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PylonsBalanceRequest proto.InternalMessageInfo

func (m *PylonsBalanceRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type PylonsBalanceResponse struct {
	Balance int64 `protobuf:"varint,1,opt,name=balance,proto3" json:"balance,omitempty"`
}

func (m *PylonsBalanceResponse) Reset()         { *m = PylonsBalanceResponse{} }
func (m *PylonsBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*PylonsBalanceResponse) ProtoMessage()    {}
func (*PylonsBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{37}
}
func (m *PylonsBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PylonsBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PylonsBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PylonsBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PylonsBalanceResponse.Merge(m, src)
}
func (m *PylonsBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *PylonsBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PylonsBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PylonsBalanceResponse proto.InternalMessageInfo

func (m *PylonsBalanceResponse) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func init() {
	proto.RegisterType((*AddrFromPubKeyRequest)(nil), "pylons.AddrFromPubKeyRequest")
	proto.RegisterType((*AddrFromPubKeyResponse)(nil), "pylons.AddrFromPubKeyResponse")
	proto.RegisterType((*CheckGoogleIAPOrderRequest)(nil), "pylons.CheckGoogleIAPOrderRequest")
	proto.RegisterType((*CheckGoogleIAPOrderResponse)(nil), "pylons.CheckGoogleIAPOrderResponse")
	proto.RegisterType((*GetCookbookRequest)(nil), "pylons.GetCookbookRequest")
	proto.RegisterType((*GetCookbookResponse)(nil), "pylons.GetCookbookResponse")
	proto.RegisterType((*GetExecutionRequest)(nil), "pylons.GetExecutionRequest")
	proto.RegisterType((*GetExecutionResponse)(nil), "pylons.GetExecutionResponse")
	proto.RegisterType((*GetItemRequest)(nil), "pylons.GetItemRequest")
	proto.RegisterType((*GetItemResponse)(nil), "pylons.GetItemResponse")
	proto.RegisterType((*GetRecipeRequest)(nil), "pylons.GetRecipeRequest")
	proto.RegisterType((*GetRecipeResponse)(nil), "pylons.GetRecipeResponse")
	proto.RegisterType((*GetTradeRequest)(nil), "pylons.GetTradeRequest")
	proto.RegisterType((*GetTradeResponse)(nil), "pylons.GetTradeResponse")
	proto.RegisterType((*ItemsByCookbookRequest)(nil), "pylons.ItemsByCookbookRequest")
	proto.RegisterType((*ItemsByCookbookResponse)(nil), "pylons.ItemsByCookbookResponse")
	proto.RegisterType((*ItemsBySenderRequest)(nil), "pylons.ItemsBySenderRequest")
	proto.RegisterType((*ItemsBySenderResponse)(nil), "pylons.ItemsBySenderResponse")
	proto.RegisterType((*ListCookbookRequest)(nil), "pylons.ListCookbookRequest")
	proto.RegisterType((*ListCookbookResponse)(nil), "pylons.ListCookbookResponse")
	proto.RegisterType((*ListExecutionsRequest)(nil), "pylons.ListExecutionsRequest")
	proto.RegisterType((*ListExecutionsResponse)(nil), "pylons.ListExecutionsResponse")
	proto.RegisterType((*GetLockedCoinsRequest)(nil), "pylons.GetLockedCoinsRequest")
	proto.RegisterType((*GetLockedCoinsResponse)(nil), "pylons.GetLockedCoinsResponse")
	proto.RegisterType((*GetLockedCoinDetailsRequest)(nil), "pylons.GetLockedCoinDetailsRequest")
	proto.RegisterType((*GetLockedCoinDetailsResponse)(nil), "pylons.GetLockedCoinDetailsResponse")
	proto.RegisterType((*ListRecipeRequest)(nil), "pylons.ListRecipeRequest")
	proto.RegisterType((*ListRecipeResponse)(nil), "pylons.ListRecipeResponse")
	proto.RegisterType((*ListRecipeByCookbookRequest)(nil), "pylons.ListRecipeByCookbookRequest")
	proto.RegisterType((*ListRecipeByCookbookResponse)(nil), "pylons.ListRecipeByCookbookResponse")
	proto.RegisterType((*ListShortenRecipeRequest)(nil), "pylons.ListShortenRecipeRequest")
	proto.RegisterType((*ListShortenRecipeResponse)(nil), "pylons.ListShortenRecipeResponse")
	proto.RegisterType((*ListShortenRecipeByCookbookRequest)(nil), "pylons.ListShortenRecipeByCookbookRequest")
	proto.RegisterType((*ListShortenRecipeByCookbookResponse)(nil), "pylons.ListShortenRecipeByCookbookResponse")
	proto.RegisterType((*ListTradeRequest)(nil), "pylons.ListTradeRequest")
	proto.RegisterType((*ListTradeResponse)(nil), "pylons.ListTradeResponse")
	proto.RegisterType((*PylonsBalanceRequest)(nil), "pylons.PylonsBalanceRequest")
	proto.RegisterType((*PylonsBalanceResponse)(nil), "pylons.PylonsBalanceResponse")
}

func init() { proto.RegisterFile("pylons/query.proto", fileDescriptor_dbe4a0dc0744f938) }

var fileDescriptor_dbe4a0dc0744f938 = []byte{
	// 2015 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xdd, 0x6f, 0x1b, 0x59,
	0x15, 0xef, 0xd8, 0x49, 0x6c, 0x1f, 0x27, 0xd9, 0xf6, 0xe6, 0xa3, 0x93, 0x69, 0xd6, 0x0d, 0xd3,
	0x50, 0xbc, 0x4d, 0xea, 0x49, 0xd2, 0x94, 0x14, 0x2d, 0x95, 0x68, 0xe2, 0x26, 0x6b, 0x51, 0x75,
	0xbb, 0xee, 0x0a, 0x04, 0x42, 0xb2, 0xc6, 0xe3, 0xbb, 0xf1, 0xc8, 0x1f, 0xe3, 0xce, 0x8c, 0xab,
	0x58, 0x91, 0x25, 0xb4, 0x2f, 0x88, 0x17, 0x84, 0xc4, 0x23, 0x82, 0x3f, 0x00, 0xc4, 0x33, 0x0f,
	0xfc, 0x03, 0xfb, 0xb8, 0x12, 0x42, 0xe2, 0x89, 0x8f, 0x96, 0x67, 0xfe, 0x03, 0x24, 0x74, 0xbf,
	0x66, 0xee, 0x8c, 0x67, 0x9c, 0x34, 0xd0, 0xa7, 0xf8, 0x9e, 0xcf, 0xdf, 0x3d, 0xe7, 0xdc, 0x33,
	0xe7, 0xde, 0x00, 0x1a, 0x8c, 0xba, 0x4e, 0xdf, 0x33, 0x5e, 0x0d, 0xb1, 0x3b, 0xaa, 0x0c, 0x5c,
	0xc7, 0x77, 0xd0, 0x1c, 0xa3, 0x69, 0x4b, 0x9c, 0xc7, 0xfe, 0x30, 0xa6, 0xb6, 0x7c, 0xea, 0x9c,
	0x3a, 0xf4, 0xa7, 0x41, 0x7e, 0x71, 0xea, 0xfa, 0xa9, 0xe3, 0x9c, 0x76, 0xb1, 0x61, 0x0e, 0x6c,
	0xc3, 0xec, 0xf7, 0x1d, 0xdf, 0xf4, 0xed, 0x50, 0xa7, 0x64, 0x39, 0x5e, 0xcf, 0xf1, 0x8c, 0xa6,
	0xe9, 0x61, 0xe3, 0xf5, 0x6e, 0x13, 0xfb, 0xe6, 0xae, 0x61, 0x39, 0x76, 0x9f, 0xf1, 0xf5, 0x03,
	0x58, 0x79, 0xd2, 0x6a, 0xb9, 0xc7, 0xae, 0xd3, 0x7b, 0x31, 0x6c, 0x7e, 0x1f, 0x8f, 0xea, 0xf8,
	0xd5, 0x10, 0x7b, 0x3e, 0x2a, 0x41, 0xb1, 0x8d, 0xcf, 0x1a, 0x83, 0x61, 0xb3, 0xd1, 0xc1, 0x23,
	0x55, 0xd9, 0x50, 0xca, 0x85, 0x7a, 0xa1, 0x8d, 0xcf, 0x98, 0x98, 0xfe, 0x08, 0x56, 0xe3, 0x8a,
	0xde, 0xc0, 0xe9, 0x7b, 0x18, 0x95, 0x00, 0x0e, 0xb1, 0xd5, 0x7e, 0xb0, 0x47, 0xf8, 0x5c, 0x51,
	0xa2, 0xe8, 0x87, 0xa0, 0x1d, 0xb5, 0xb1, 0xd5, 0x39, 0xa1, 0xb8, 0x6b, 0x4f, 0x5e, 0x7c, 0xea,
	0xb6, 0xb0, 0x2b, 0xfc, 0x6e, 0xc2, 0xc2, 0x60, 0xe8, 0x5a, 0x6d, 0xd3, 0xc3, 0x9f, 0x3b, 0x1d,
	0xdc, 0xe7, 0x06, 0xa2, 0x44, 0xfd, 0x47, 0x70, 0x2b, 0xd1, 0x06, 0x87, 0x70, 0x29, 0x23, 0x68,
	0x19, 0x66, 0xf1, 0x99, 0xed, 0xf9, 0x6a, 0x66, 0x43, 0x29, 0xe7, 0xeb, 0x6c, 0xa1, 0xef, 0x03,
	0x3a, 0xc1, 0xfe, 0x91, 0xe3, 0x74, 0x9a, 0x8e, 0xd3, 0x09, 0xc3, 0x01, 0x16, 0x27, 0xd5, 0xaa,
	0x62, 0x53, 0x21, 0x45, 0xff, 0x7d, 0x06, 0x96, 0x22, 0x6a, 0x1c, 0xc9, 0x06, 0x14, 0x9f, 0x3b,
	0x2d, 0xfc, 0x03, 0xec, 0x7a, 0xb6, 0x23, 0x70, 0xc8, 0x24, 0xb4, 0x08, 0x99, 0x5a, 0x95, 0x42,
	0x28, 0xd4, 0x33, 0xb5, 0x2a, 0x42, 0x30, 0xf3, 0xdc, 0xec, 0x61, 0x35, 0x4b, 0x29, 0xf4, 0x37,
	0xb1, 0x52, 0xc5, 0x9e, 0xe5, 0xda, 0x03, 0x92, 0x5b, 0x75, 0x86, 0x59, 0x91, 0x48, 0x48, 0x85,
	0x9c, 0xf0, 0x31, 0x4b, 0xb9, 0x62, 0x89, 0xd6, 0xa1, 0x50, 0xc5, 0xaf, 0x71, 0xd7, 0x19, 0x60,
	0x57, 0x9d, 0x63, 0x69, 0x0c, 0x08, 0x24, 0x06, 0xcf, 0xc8, 0x42, 0xcd, 0x6d, 0x28, 0xe5, 0x6c,
	0x9d, 0x2d, 0x90, 0x0e, 0xf3, 0x2f, 0x87, 0x83, 0x81, 0xe3, 0xfa, 0x4f, 0x7b, 0xa6, 0xdd, 0x55,
	0xf3, 0x54, 0x2d, 0x42, 0x23, 0x32, 0x47, 0x8e, 0xe7, 0xbf, 0xc0, 0xee, 0x61, 0xd7, 0xb1, 0x3a,
	0x6a, 0x81, 0x1a, 0x88, 0xd0, 0xd0, 0x2a, 0xcc, 0xbd, 0xc4, 0xfd, 0x16, 0x76, 0x55, 0xa0, 0x16,
	0xf8, 0x4a, 0x3f, 0xa0, 0xc1, 0x7a, 0x7a, 0x86, 0xad, 0x21, 0x41, 0x2f, 0x82, 0xbc, 0x01, 0x45,
	0x2c, 0x68, 0x41, 0x94, 0x65, 0x92, 0xfe, 0x9f, 0x0c, 0x2c, 0x47, 0x35, 0xaf, 0x1c, 0x67, 0x0d,
	0xf2, 0x75, 0x6c, 0xd9, 0x03, 0x5c, 0xab, 0xf2, 0x58, 0x07, 0x6b, 0x92, 0xed, 0xa3, 0x30, 0xdb,
	0x2c, 0xdc, 0x12, 0x05, 0x75, 0x08, 0xdf, 0xee, 0x7b, 0xb5, 0xfe, 0x60, 0xe8, 0xab, 0xb3, 0x1b,
	0xd9, 0x72, 0x71, 0x6f, 0xad, 0xc2, 0x8e, 0x5a, 0x85, 0x1c, 0xb5, 0x0a, 0x3f, 0x6a, 0x15, 0x22,
	0x76, 0xb8, 0xf3, 0xd5, 0xdf, 0x6e, 0x5f, 0xfb, 0xdd, 0xdf, 0x6f, 0x97, 0x4f, 0x6d, 0xbf, 0x3d,
	0x6c, 0x56, 0x2c, 0xa7, 0x67, 0xf0, 0x73, 0xc9, 0xfe, 0xdc, 0xf7, 0x5a, 0x1d, 0xc3, 0x1f, 0x0d,
	0xb0, 0x47, 0x15, 0xbc, 0xba, 0x64, 0x1e, 0xed, 0x01, 0xd4, 0x7c, 0xdc, 0xa3, 0x0b, 0x4f, 0x9d,
	0xa3, 0xce, 0xe6, 0x2b, 0xbc, 0x33, 0x10, 0xce, 0xe1, 0x0c, 0xb1, 0x5f, 0x97, 0xa4, 0x48, 0x38,
	0x68, 0x06, 0x3e, 0xc1, 0xf6, 0x69, 0xdb, 0xe7, 0xc9, 0x95, 0x49, 0x52, 0x6a, 0xf2, 0x72, 0x6a,
	0x48, 0xb9, 0x1c, 0x39, 0xbd, 0x41, 0x17, 0xfb, 0xb8, 0x45, 0x73, 0x9a, 0xaf, 0x87, 0x04, 0xbd,
	0x0c, 0x8b, 0x27, 0xd8, 0x27, 0x8e, 0x44, 0xce, 0x56, 0x61, 0xce, 0x26, 0x7e, 0x45, 0xba, 0xf8,
	0x4a, 0xff, 0x0e, 0x7c, 0x10, 0x48, 0xf2, 0x1c, 0xdd, 0x85, 0x19, 0xc2, 0xa4, 0x82, 0xc9, 0x5b,
	0xa0, 0x7c, 0xbd, 0x02, 0xd7, 0x4f, 0xb0, 0xcf, 0x92, 0x21, 0xdc, 0x68, 0x90, 0x77, 0x45, 0xb6,
	0x98, 0xa3, 0x60, 0xad, 0xff, 0x25, 0x0b, 0x37, 0x24, 0x85, 0x2b, 0x57, 0x44, 0x34, 0xeb, 0xd9,
	0x89, 0xac, 0x8b, 0x93, 0x39, 0x23, 0x9d, 0xcc, 0x03, 0x56, 0x09, 0x3c, 0x39, 0xac, 0x12, 0x6e,
	0x88, 0x9d, 0x05, 0x1c, 0x91, 0xa1, 0x50, 0x94, 0x28, 0x4e, 0x64, 0xf5, 0x86, 0x1c, 0x92, 0x88,
	0xa2, 0x94, 0xda, 0x07, 0x90, 0x7b, 0xda, 0xf7, 0x5d, 0x1b, 0x7b, 0x34, 0xad, 0xc5, 0xbd, 0x25,
	0xa1, 0xc5, 0xc9, 0xcf, 0x6c, 0x4f, 0xe8, 0x09, 0x49, 0x74, 0x00, 0xb9, 0x4f, 0x87, 0x3e, 0x75,
	0x95, 0xa7, 0xae, 0x6e, 0x0a, 0xa5, 0x1f, 0xd2, 0x72, 0xc0, 0x2d, 0xce, 0x16, 0x8a, 0x7c, 0x19,
	0xef, 0x3c, 0x85, 0xc9, 0xce, 0xb3, 0x09, 0x0b, 0xb4, 0xae, 0x6a, 0x7d, 0x1f, 0xbb, 0xaf, 0xcd,
	0x2e, 0x3d, 0xea, 0xd9, 0x7a, 0x94, 0x28, 0x95, 0x5b, 0x31, 0x52, 0x6e, 0x1a, 0xe4, 0xab, 0xb6,
	0x67, 0x36, 0xbb, 0xb8, 0xa5, 0xce, 0xd3, 0x6a, 0x0b, 0xd6, 0xfa, 0x16, 0x2d, 0xa1, 0xcf, 0x5d,
	0xb3, 0x15, 0x94, 0x81, 0x0a, 0x39, 0x9f, 0xac, 0x83, 0x2a, 0x10, 0x4b, 0xfd, 0xdf, 0x59, 0x5a,
	0x35, 0x5c, 0xfa, 0xca, 0x35, 0x10, 0xcd, 0x67, 0xf6, 0xf2, 0xf9, 0xfc, 0x6e, 0x24, 0x9f, 0x33,
	0x54, 0x71, 0x55, 0x28, 0x52, 0x54, 0xd3, 0x92, 0xda, 0x83, 0x22, 0xb1, 0x25, 0x72, 0xf4, 0x1e,
	0x3a, 0x8a, 0x6c, 0x1f, 0xed, 0x43, 0x91, 0x38, 0x17, 0xee, 0xd2, 0x7b, 0x8a, 0x2c, 0x46, 0x5a,
	0xc3, 0xd3, 0x33, 0xdf, 0x35, 0x6b, 0xfd, 0x2f, 0x1c, 0x5a, 0x7b, 0x85, 0x7a, 0x48, 0x98, 0xd6,
	0x50, 0x8e, 0x87, 0xdd, 0x63, 0xbb, 0xdb, 0xc5, 0x2e, 0xaf, 0x9f, 0x90, 0x10, 0xc9, 0x3f, 0x44,
	0xf3, 0x1f, 0x6d, 0x45, 0xc5, 0x78, 0x2b, 0x7a, 0x04, 0xab, 0x04, 0x9c, 0x77, 0x38, 0x7a, 0xd7,
	0x6f, 0xf5, 0x11, 0xdc, 0x9c, 0xd0, 0xe4, 0x05, 0x53, 0x86, 0x59, 0xca, 0x52, 0x95, 0xd4, 0x90,
	0x30, 0x01, 0xbd, 0x02, 0xcb, 0xdc, 0x08, 0xdb, 0xa7, 0xd4, 0x0f, 0x3d, 0x16, 0x06, 0xde, 0x0f,
	0xd9, 0x4a, 0x7f, 0x02, 0x2b, 0x31, 0xf9, 0x77, 0x76, 0x69, 0xc0, 0x12, 0x39, 0xdb, 0xf1, 0xed,
	0xaa, 0x90, 0x33, 0x5b, 0x2d, 0x17, 0x7b, 0x9e, 0x38, 0x13, 0x7c, 0xa9, 0x3f, 0x83, 0xe5, 0xa8,
	0x02, 0x77, 0xb9, 0x4f, 0x02, 0xcb, 0x68, 0xc2, 0xed, 0xf5, 0xb0, 0xc6, 0x19, 0x83, 0xbb, 0x0e,
	0x05, 0x75, 0x03, 0x56, 0x88, 0xb5, 0xe0, 0xdb, 0xeb, 0x5d, 0xb4, 0xe5, 0xcf, 0x60, 0x35, 0xae,
	0xc0, 0x01, 0x1c, 0x00, 0x84, 0x54, 0x8e, 0x20, 0x38, 0x65, 0x01, 0x47, 0x9c, 0x93, 0x50, 0x54,
	0xdf, 0x85, 0x95, 0x13, 0xec, 0x3f, 0x73, 0xac, 0x0e, 0x6e, 0xb1, 0xba, 0xbe, 0x30, 0x08, 0x7f,
	0x54, 0x60, 0x35, 0xae, 0x73, 0xe9, 0xf6, 0x10, 0x16, 0x75, 0x26, 0x52, 0xd4, 0x16, 0xcc, 0x3d,
	0xe9, 0x39, 0xc3, 0xbe, 0xcf, 0x5b, 0xc4, 0xff, 0xf5, 0xa8, 0x72, 0xd3, 0xfa, 0x01, 0xdc, 0x8a,
	0x00, 0xaf, 0x62, 0xdf, 0xb4, 0xbb, 0x97, 0xd8, 0xf2, 0x1f, 0x32, 0xb0, 0x9e, 0xac, 0xc9, 0x37,
	0x9e, 0x92, 0x31, 0x69, 0x5b, 0x99, 0xf7, 0xb6, 0x2d, 0xf4, 0x09, 0x2c, 0x12, 0x64, 0x84, 0x48,
	0xfb, 0xa2, 0x68, 0xb3, 0x9a, 0x28, 0x00, 0x19, 0x37, 0xf9, 0xce, 0x34, 0x31, 0xaf, 0x84, 0x98,
	0x1e, 0x3a, 0x86, 0x05, 0x41, 0x21, 0x35, 0x22, 0xda, 0xee, 0xc5, 0x86, 0xa2, 0x6a, 0xfa, 0x7d,
	0xb8, 0x41, 0x0a, 0x35, 0x3a, 0x71, 0xa4, 0x87, 0xb7, 0x0a, 0x48, 0x16, 0xe7, 0x31, 0xad, 0x40,
	0x8e, 0x4d, 0x24, 0xa2, 0xa0, 0x17, 0x05, 0x0c, 0x26, 0x28, 0xbe, 0xac, 0x5c, 0x48, 0x7f, 0x0c,
	0xb7, 0x42, 0x2b, 0xef, 0xde, 0xc4, 0x9e, 0xc3, 0x7a, 0xb2, 0xfa, 0x15, 0xe1, 0xec, 0x83, 0x4a,
	0xec, 0xbd, 0x6c, 0x3b, 0xae, 0x8f, 0xfb, 0x97, 0x0d, 0x45, 0x1d, 0xd6, 0x12, 0xb4, 0x38, 0x84,
	0x87, 0x71, 0x08, 0x2b, 0x02, 0x42, 0x44, 0x3e, 0x8e, 0xa4, 0x0a, 0xfa, 0x84, 0xcd, 0x77, 0x8f,
	0xcf, 0x4f, 0xe0, 0xce, 0x54, 0x2b, 0xff, 0x1b, 0xc6, 0x6d, 0xb8, 0x4e, 0xac, 0xc7, 0x67, 0x93,
	0x94, 0x28, 0x7d, 0x8f, 0xd5, 0x57, 0x74, 0x36, 0xd9, 0x82, 0x39, 0x9f, 0x95, 0x3f, 0x73, 0xbc,
	0x10, 0x19, 0x16, 0xb8, 0x43, 0x2e, 0xa2, 0xef, 0xc0, 0xf2, 0x0b, 0xca, 0x3d, 0x34, 0xbb, 0x66,
	0xdf, 0xba, 0x84, 0xcf, 0x5d, 0x58, 0x89, 0x69, 0x70, 0xbf, 0x2a, 0xe4, 0x9a, 0x8c, 0x44, 0x55,
	0xb2, 0x75, 0xb1, 0xdc, 0xfb, 0xe7, 0x12, 0xcc, 0x7e, 0x36, 0xc4, 0xee, 0x08, 0xfd, 0x4c, 0x81,
	0xc5, 0xe8, 0xed, 0x1e, 0x7d, 0x28, 0xe0, 0x25, 0x3e, 0x17, 0x68, 0xa5, 0x34, 0x36, 0xf3, 0xaa,
	0x7f, 0xfb, 0xcb, 0x3f, 0xff, 0xeb, 0x57, 0x99, 0x1d, 0x54, 0x31, 0xac, 0xa1, 0xe7, 0x3b, 0x3d,
	0xfe, 0xb2, 0x61, 0x10, 0xb8, 0x8d, 0x2f, 0x5c, 0xa7, 0x27, 0x5e, 0x1a, 0x8c, 0x73, 0xe9, 0xd9,
	0x61, 0x8c, 0x7e, 0xa3, 0xc0, 0x52, 0xc2, 0x4d, 0x1f, 0xe9, 0xc1, 0xf7, 0x2a, 0xf5, 0x29, 0x41,
	0xbb, 0x33, 0x55, 0x86, 0x03, 0x7b, 0x4c, 0x81, 0x1d, 0xa0, 0x87, 0x31, 0x60, 0x16, 0xd1, 0x69,
	0xb0, 0xb7, 0x95, 0x86, 0x6d, 0x0e, 0x1a, 0x0e, 0x51, 0x33, 0xce, 0x23, 0x4f, 0x08, 0x63, 0x74,
	0x06, 0x45, 0xe9, 0xda, 0x8f, 0x82, 0xd6, 0x33, 0xf9, 0x84, 0xa0, 0xdd, 0x4a, 0xe4, 0x71, 0x18,
	0x3b, 0x14, 0xc6, 0x3d, 0x54, 0x8e, 0xc1, 0x38, 0xc5, 0x7e, 0x43, 0x54, 0xb5, 0x71, 0x1e, 0xd6,
	0xf7, 0x18, 0x8d, 0x61, 0x5e, 0xbe, 0x09, 0x23, 0xd9, 0x7c, 0xfc, 0x66, 0xad, 0xad, 0x27, 0x33,
	0xb9, 0xf3, 0x3d, 0xea, 0x7c, 0x1b, 0xdd, 0x4b, 0x70, 0x1e, 0xdc, 0xbe, 0x8d, 0x73, 0xe9, 0x22,
	0x3e, 0x46, 0x2d, 0xc8, 0xf1, 0xfb, 0x1d, 0x5a, 0x95, 0x8c, 0x4b, 0x57, 0x43, 0xed, 0xe6, 0x04,
	0x9d, 0xfb, 0x2b, 0x53, 0x7f, 0x3a, 0xda, 0x48, 0xf0, 0x47, 0x6e, 0x80, 0xc6, 0x39, 0xbb, 0x44,
	0x8e, 0x51, 0x1f, 0x0a, 0xc1, 0xcd, 0x0e, 0xa9, 0x92, 0xbd, 0x48, 0x83, 0xd2, 0xd6, 0x12, 0x38,
	0xdc, 0xd7, 0x36, 0xf5, 0x75, 0x17, 0x6d, 0x26, 0xf8, 0x62, 0xa7, 0xd9, 0x38, 0x17, 0x37, 0xc9,
	0x31, 0xb2, 0x21, 0x2f, 0x2e, 0x11, 0x48, 0x86, 0x2f, 0x1f, 0x74, 0x4d, 0x9d, 0x64, 0x70, 0x67,
	0xf7, 0xa8, 0xb3, 0x4d, 0xa4, 0x27, 0x38, 0xa3, 0x27, 0xd9, 0x38, 0xe7, 0xf7, 0x95, 0x31, 0xfa,
	0xb9, 0x02, 0x1f, 0xc4, 0xc6, 0x50, 0x54, 0x92, 0x87, 0xbf, 0xc9, 0xc9, 0x56, 0xbb, 0x9d, 0xca,
	0xe7, 0x00, 0x1e, 0x52, 0x00, 0x06, 0xba, 0x1f, 0x03, 0x40, 0xe2, 0xe9, 0x35, 0x9a, 0xa3, 0xd4,
	0x5a, 0x5a, 0x88, 0x0c, 0xa7, 0x68, 0x3d, 0xe6, 0x28, 0x32, 0xe3, 0x6a, 0x1f, 0xa6, 0x70, 0x39,
	0x08, 0x83, 0x82, 0xf8, 0x08, 0x7d, 0x2b, 0x0d, 0x04, 0x9b, 0x36, 0x8c, 0x73, 0xf6, 0x77, 0x8c,
	0x46, 0x30, 0x2f, 0xcf, 0xa9, 0x61, 0x29, 0x27, 0x8c, 0xbb, 0x61, 0x29, 0x27, 0x8d, 0xb6, 0x7a,
	0x85, 0xfa, 0x2e, 0xa3, 0xbb, 0x31, 0xdf, 0x5d, 0xdb, 0x93, 0x0f, 0x12, 0xef, 0x92, 0x63, 0xf4,
	0x53, 0x05, 0x16, 0xa3, 0x43, 0x6a, 0xd8, 0xe9, 0x12, 0xa7, 0xdd, 0xb0, 0xd3, 0x25, 0xcf, 0xb6,
	0xa9, 0xbb, 0xa7, 0x08, 0x82, 0x23, 0xe4, 0x85, 0xbb, 0xff, 0x52, 0xa1, 0x8f, 0x2a, 0xd2, 0x80,
	0x1a, 0x42, 0x48, 0x1c, 0x76, 0x43, 0x08, 0xc9, 0x73, 0xad, 0xbe, 0x4b, 0x21, 0x6c, 0xa1, 0x8f,
	0x12, 0xca, 0xb0, 0x4b, 0xe5, 0x1b, 0x16, 0x51, 0x90, 0xe2, 0xf0, 0x6b, 0x85, 0x3e, 0xac, 0x4d,
	0x8c, 0x8c, 0xe8, 0x4e, 0xa2, 0xaf, 0xe8, 0x28, 0xaa, 0x6d, 0x4e, 0x17, 0xe2, 0xb0, 0x1e, 0x51,
	0x58, 0x7b, 0x68, 0x67, 0x3a, 0xac, 0x46, 0x8b, 0xe9, 0x49, 0xe8, 0x5e, 0x01, 0x84, 0xc3, 0x0e,
	0x5a, 0x93, 0x33, 0x10, 0x6d, 0x04, 0x5a, 0x12, 0xeb, 0x82, 0x4e, 0x40, 0x13, 0x23, 0x5a, 0x41,
	0xe0, 0xf2, 0xb7, 0x0a, 0xbb, 0x3c, 0xc5, 0x27, 0x87, 0x30, 0x20, 0x53, 0xa6, 0xb7, 0x30, 0x20,
	0xd3, 0x66, 0x34, 0xfd, 0x63, 0x8a, 0xe8, 0x21, 0x7a, 0x90, 0x8e, 0x28, 0xfd, 0xcc, 0xfe, 0x42,
	0x61, 0x53, 0x45, 0x64, 0x4e, 0x41, 0x1b, 0xb2, 0xe3, 0xa4, 0x61, 0x4e, 0xfb, 0xc6, 0x14, 0x09,
	0x8e, 0x6b, 0x9f, 0xe2, 0xaa, 0xa0, 0xed, 0x24, 0x5c, 0x1e, 0x53, 0x99, 0x8c, 0xd8, 0x9f, 0x14,
	0x36, 0xd1, 0xa6, 0x8c, 0x5c, 0xe8, 0x5e, 0xaa, 0xe3, 0xc9, 0xf8, 0x6d, 0x5d, 0x4a, 0x96, 0xc3,
	0x3d, 0xa2, 0x70, 0x1f, 0xa3, 0x8f, 0x2f, 0x86, 0x9b, 0x1e, 0xce, 0x1e, 0x14, 0x82, 0x19, 0x2d,
	0xfc, 0xd2, 0xc4, 0x87, 0x3c, 0x6d, 0x2d, 0x81, 0xc3, 0x61, 0x6c, 0x51, 0x18, 0xdf, 0x44, 0x77,
	0x92, 0x60, 0xf0, 0xee, 0x1f, 0x04, 0xeb, 0x35, 0x2c, 0x44, 0xc6, 0xb3, 0xb0, 0xe3, 0x26, 0xcd,
	0x79, 0x61, 0xc7, 0x4d, 0x9c, 0xe9, 0x52, 0x3f, 0xa8, 0x7c, 0xb2, 0x0b, 0xfd, 0x1e, 0x1e, 0x7f,
	0xf5, 0xa6, 0xa4, 0x7c, 0xfd, 0xa6, 0xa4, 0xfc, 0xe3, 0x4d, 0x49, 0xf9, 0xe5, 0xdb, 0xd2, 0xb5,
	0xaf, 0xdf, 0x96, 0xae, 0xfd, 0xf5, 0x6d, 0xe9, 0xda, 0x8f, 0xb7, 0xa5, 0x8b, 0x1c, 0xf3, 0x72,
	0xdf, 0xc7, 0x56, 0x5b, 0x98, 0x3a, 0x13, 0x3f, 0xe8, 0x95, 0xae, 0x39, 0x47, 0xff, 0x7d, 0xf4,
	0xe0, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7b, 0xea, 0x13, 0x99, 0xc5, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// AddrFromPubKey returns a bech32 public address from the public key
	AddrFromPubKey(ctx context.Context, in *AddrFromPubKeyRequest, opts ...grpc.CallOption) (*AddrFromPubKeyResponse, error)
	// CheckGoogleIAPOrder check if google iap order is given to user with purchase token
	CheckGoogleIAPOrder(ctx context.Context, in *CheckGoogleIAPOrderRequest, opts ...grpc.CallOption) (*CheckGoogleIAPOrderResponse, error)
	// GetCookbook returns a cookbook based on the cookbook id
	GetCookbook(ctx context.Context, in *GetCookbookRequest, opts ...grpc.CallOption) (*GetCookbookResponse, error)
	// GetExecution returns an execution based on the execution id
	GetExecution(ctx context.Context, in *GetExecutionRequest, opts ...grpc.CallOption) (*GetExecutionResponse, error)
	// GetItem returns a item based on the item id
	GetItem(ctx context.Context, in *GetItemRequest, opts ...grpc.CallOption) (*GetItemResponse, error)
	// GetRecipe returns a recipe based on the recipe id
	GetRecipe(ctx context.Context, in *GetRecipeRequest, opts ...grpc.CallOption) (*GetRecipeResponse, error)
	// GetTrade returns a trade based on the trade id
	GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeResponse, error)
	// ItemsByCookbook returns a cookbook based on the cookbook id
	ItemsByCookbook(ctx context.Context, in *ItemsByCookbookRequest, opts ...grpc.CallOption) (*ItemsByCookbookResponse, error)
	// ItemsBySender returns all items based on the sender address
	ItemsBySender(ctx context.Context, in *ItemsBySenderRequest, opts ...grpc.CallOption) (*ItemsBySenderResponse, error)
	// ListCookbook returns a cookbook based on the cookbook id
	ListCookbook(ctx context.Context, in *ListCookbookRequest, opts ...grpc.CallOption) (*ListCookbookResponse, error)
	// ListExecutions lists all the executions based on the sender address
	ListExecutions(ctx context.Context, in *ListExecutionsRequest, opts ...grpc.CallOption) (*ListExecutionsResponse, error)
	// GetLockedCoins returns locked coins based on user
	GetLockedCoins(ctx context.Context, in *GetLockedCoinsRequest, opts ...grpc.CallOption) (*GetLockedCoinsResponse, error)
	// GetLockedCoinDetails returns locked coins with details based on user
	GetLockedCoinDetails(ctx context.Context, in *GetLockedCoinDetailsRequest, opts ...grpc.CallOption) (*GetLockedCoinDetailsResponse, error)
	// ListRecipe returns a recipe based on the recipe id
	ListRecipe(ctx context.Context, in *ListRecipeRequest, opts ...grpc.CallOption) (*ListRecipeResponse, error)
	// ListRecipeByCookbook returns a recipe based on the recipe id
	ListRecipeByCookbook(ctx context.Context, in *ListRecipeByCookbookRequest, opts ...grpc.CallOption) (*ListRecipeByCookbookResponse, error)
	// ListShortenRecipe returns a recipe based on the recipe id
	ListShortenRecipe(ctx context.Context, in *ListShortenRecipeRequest, opts ...grpc.CallOption) (*ListShortenRecipeResponse, error)
	// ListShortenRecipeByCookbook returns a recipe based on the recipe id
	ListShortenRecipeByCookbook(ctx context.Context, in *ListShortenRecipeByCookbookRequest, opts ...grpc.CallOption) (*ListShortenRecipeByCookbookResponse, error)
	// ListTrade returns a trade based on the trade id
	ListTrade(ctx context.Context, in *ListTradeRequest, opts ...grpc.CallOption) (*ListTradeResponse, error)
	// PylonsBalance provides balances in pylons
	PylonsBalance(ctx context.Context, in *PylonsBalanceRequest, opts ...grpc.CallOption) (*PylonsBalanceResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) AddrFromPubKey(ctx context.Context, in *AddrFromPubKeyRequest, opts ...grpc.CallOption) (*AddrFromPubKeyResponse, error) {
	out := new(AddrFromPubKeyResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/AddrFromPubKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CheckGoogleIAPOrder(ctx context.Context, in *CheckGoogleIAPOrderRequest, opts ...grpc.CallOption) (*CheckGoogleIAPOrderResponse, error) {
	out := new(CheckGoogleIAPOrderResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/CheckGoogleIAPOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetCookbook(ctx context.Context, in *GetCookbookRequest, opts ...grpc.CallOption) (*GetCookbookResponse, error) {
	out := new(GetCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetExecution(ctx context.Context, in *GetExecutionRequest, opts ...grpc.CallOption) (*GetExecutionResponse, error) {
	out := new(GetExecutionResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetItem(ctx context.Context, in *GetItemRequest, opts ...grpc.CallOption) (*GetItemResponse, error) {
	out := new(GetItemResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetRecipe(ctx context.Context, in *GetRecipeRequest, opts ...grpc.CallOption) (*GetRecipeResponse, error) {
	out := new(GetRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeResponse, error) {
	out := new(GetTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ItemsByCookbook(ctx context.Context, in *ItemsByCookbookRequest, opts ...grpc.CallOption) (*ItemsByCookbookResponse, error) {
	out := new(ItemsByCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ItemsByCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ItemsBySender(ctx context.Context, in *ItemsBySenderRequest, opts ...grpc.CallOption) (*ItemsBySenderResponse, error) {
	out := new(ItemsBySenderResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ItemsBySender", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListCookbook(ctx context.Context, in *ListCookbookRequest, opts ...grpc.CallOption) (*ListCookbookResponse, error) {
	out := new(ListCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListExecutions(ctx context.Context, in *ListExecutionsRequest, opts ...grpc.CallOption) (*ListExecutionsResponse, error) {
	out := new(ListExecutionsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetLockedCoins(ctx context.Context, in *GetLockedCoinsRequest, opts ...grpc.CallOption) (*GetLockedCoinsResponse, error) {
	out := new(GetLockedCoinsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetLockedCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetLockedCoinDetails(ctx context.Context, in *GetLockedCoinDetailsRequest, opts ...grpc.CallOption) (*GetLockedCoinDetailsResponse, error) {
	out := new(GetLockedCoinDetailsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/GetLockedCoinDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListRecipe(ctx context.Context, in *ListRecipeRequest, opts ...grpc.CallOption) (*ListRecipeResponse, error) {
	out := new(ListRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListRecipeByCookbook(ctx context.Context, in *ListRecipeByCookbookRequest, opts ...grpc.CallOption) (*ListRecipeByCookbookResponse, error) {
	out := new(ListRecipeByCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListRecipeByCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListShortenRecipe(ctx context.Context, in *ListShortenRecipeRequest, opts ...grpc.CallOption) (*ListShortenRecipeResponse, error) {
	out := new(ListShortenRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListShortenRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListShortenRecipeByCookbook(ctx context.Context, in *ListShortenRecipeByCookbookRequest, opts ...grpc.CallOption) (*ListShortenRecipeByCookbookResponse, error) {
	out := new(ListShortenRecipeByCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListShortenRecipeByCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListTrade(ctx context.Context, in *ListTradeRequest, opts ...grpc.CallOption) (*ListTradeResponse, error) {
	out := new(ListTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/ListTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PylonsBalance(ctx context.Context, in *PylonsBalanceRequest, opts ...grpc.CallOption) (*PylonsBalanceResponse, error) {
	out := new(PylonsBalanceResponse)
	err := c.cc.Invoke(ctx, "/pylons.Query/PylonsBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// AddrFromPubKey returns a bech32 public address from the public key
	AddrFromPubKey(context.Context, *AddrFromPubKeyRequest) (*AddrFromPubKeyResponse, error)
	// CheckGoogleIAPOrder check if google iap order is given to user with purchase token
	CheckGoogleIAPOrder(context.Context, *CheckGoogleIAPOrderRequest) (*CheckGoogleIAPOrderResponse, error)
	// GetCookbook returns a cookbook based on the cookbook id
	GetCookbook(context.Context, *GetCookbookRequest) (*GetCookbookResponse, error)
	// GetExecution returns an execution based on the execution id
	GetExecution(context.Context, *GetExecutionRequest) (*GetExecutionResponse, error)
	// GetItem returns a item based on the item id
	GetItem(context.Context, *GetItemRequest) (*GetItemResponse, error)
	// GetRecipe returns a recipe based on the recipe id
	GetRecipe(context.Context, *GetRecipeRequest) (*GetRecipeResponse, error)
	// GetTrade returns a trade based on the trade id
	GetTrade(context.Context, *GetTradeRequest) (*GetTradeResponse, error)
	// ItemsByCookbook returns a cookbook based on the cookbook id
	ItemsByCookbook(context.Context, *ItemsByCookbookRequest) (*ItemsByCookbookResponse, error)
	// ItemsBySender returns all items based on the sender address
	ItemsBySender(context.Context, *ItemsBySenderRequest) (*ItemsBySenderResponse, error)
	// ListCookbook returns a cookbook based on the cookbook id
	ListCookbook(context.Context, *ListCookbookRequest) (*ListCookbookResponse, error)
	// ListExecutions lists all the executions based on the sender address
	ListExecutions(context.Context, *ListExecutionsRequest) (*ListExecutionsResponse, error)
	// GetLockedCoins returns locked coins based on user
	GetLockedCoins(context.Context, *GetLockedCoinsRequest) (*GetLockedCoinsResponse, error)
	// GetLockedCoinDetails returns locked coins with details based on user
	GetLockedCoinDetails(context.Context, *GetLockedCoinDetailsRequest) (*GetLockedCoinDetailsResponse, error)
	// ListRecipe returns a recipe based on the recipe id
	ListRecipe(context.Context, *ListRecipeRequest) (*ListRecipeResponse, error)
	// ListRecipeByCookbook returns a recipe based on the recipe id
	ListRecipeByCookbook(context.Context, *ListRecipeByCookbookRequest) (*ListRecipeByCookbookResponse, error)
	// ListShortenRecipe returns a recipe based on the recipe id
	ListShortenRecipe(context.Context, *ListShortenRecipeRequest) (*ListShortenRecipeResponse, error)
	// ListShortenRecipeByCookbook returns a recipe based on the recipe id
	ListShortenRecipeByCookbook(context.Context, *ListShortenRecipeByCookbookRequest) (*ListShortenRecipeByCookbookResponse, error)
	// ListTrade returns a trade based on the trade id
	ListTrade(context.Context, *ListTradeRequest) (*ListTradeResponse, error)
	// PylonsBalance provides balances in pylons
	PylonsBalance(context.Context, *PylonsBalanceRequest) (*PylonsBalanceResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) AddrFromPubKey(ctx context.Context, req *AddrFromPubKeyRequest) (*AddrFromPubKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddrFromPubKey not implemented")
}
func (*UnimplementedQueryServer) CheckGoogleIAPOrder(ctx context.Context, req *CheckGoogleIAPOrderRequest) (*CheckGoogleIAPOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckGoogleIAPOrder not implemented")
}
func (*UnimplementedQueryServer) GetCookbook(ctx context.Context, req *GetCookbookRequest) (*GetCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCookbook not implemented")
}
func (*UnimplementedQueryServer) GetExecution(ctx context.Context, req *GetExecutionRequest) (*GetExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecution not implemented")
}
func (*UnimplementedQueryServer) GetItem(ctx context.Context, req *GetItemRequest) (*GetItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItem not implemented")
}
func (*UnimplementedQueryServer) GetRecipe(ctx context.Context, req *GetRecipeRequest) (*GetRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecipe not implemented")
}
func (*UnimplementedQueryServer) GetTrade(ctx context.Context, req *GetTradeRequest) (*GetTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}
func (*UnimplementedQueryServer) ItemsByCookbook(ctx context.Context, req *ItemsByCookbookRequest) (*ItemsByCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemsByCookbook not implemented")
}
func (*UnimplementedQueryServer) ItemsBySender(ctx context.Context, req *ItemsBySenderRequest) (*ItemsBySenderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemsBySender not implemented")
}
func (*UnimplementedQueryServer) ListCookbook(ctx context.Context, req *ListCookbookRequest) (*ListCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCookbook not implemented")
}
func (*UnimplementedQueryServer) ListExecutions(ctx context.Context, req *ListExecutionsRequest) (*ListExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExecutions not implemented")
}
func (*UnimplementedQueryServer) GetLockedCoins(ctx context.Context, req *GetLockedCoinsRequest) (*GetLockedCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockedCoins not implemented")
}
func (*UnimplementedQueryServer) GetLockedCoinDetails(ctx context.Context, req *GetLockedCoinDetailsRequest) (*GetLockedCoinDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockedCoinDetails not implemented")
}
func (*UnimplementedQueryServer) ListRecipe(ctx context.Context, req *ListRecipeRequest) (*ListRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecipe not implemented")
}
func (*UnimplementedQueryServer) ListRecipeByCookbook(ctx context.Context, req *ListRecipeByCookbookRequest) (*ListRecipeByCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecipeByCookbook not implemented")
}
func (*UnimplementedQueryServer) ListShortenRecipe(ctx context.Context, req *ListShortenRecipeRequest) (*ListShortenRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShortenRecipe not implemented")
}
func (*UnimplementedQueryServer) ListShortenRecipeByCookbook(ctx context.Context, req *ListShortenRecipeByCookbookRequest) (*ListShortenRecipeByCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShortenRecipeByCookbook not implemented")
}
func (*UnimplementedQueryServer) ListTrade(ctx context.Context, req *ListTradeRequest) (*ListTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrade not implemented")
}
func (*UnimplementedQueryServer) PylonsBalance(ctx context.Context, req *PylonsBalanceRequest) (*PylonsBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PylonsBalance not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_AddrFromPubKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddrFromPubKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AddrFromPubKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/AddrFromPubKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AddrFromPubKey(ctx, req.(*AddrFromPubKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CheckGoogleIAPOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckGoogleIAPOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CheckGoogleIAPOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/CheckGoogleIAPOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CheckGoogleIAPOrder(ctx, req.(*CheckGoogleIAPOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCookbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetCookbook(ctx, req.(*GetCookbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetExecution(ctx, req.(*GetExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetItem(ctx, req.(*GetItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecipeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetRecipe(ctx, req.(*GetRecipeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetTrade(ctx, req.(*GetTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ItemsByCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsByCookbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ItemsByCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ItemsByCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ItemsByCookbook(ctx, req.(*ItemsByCookbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ItemsBySender_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsBySenderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ItemsBySender(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ItemsBySender",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ItemsBySender(ctx, req.(*ItemsBySenderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCookbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListCookbook(ctx, req.(*ListCookbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListExecutions(ctx, req.(*ListExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetLockedCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLockedCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetLockedCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetLockedCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetLockedCoins(ctx, req.(*GetLockedCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetLockedCoinDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLockedCoinDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetLockedCoinDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/GetLockedCoinDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetLockedCoinDetails(ctx, req.(*GetLockedCoinDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRecipeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListRecipe(ctx, req.(*ListRecipeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListRecipeByCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRecipeByCookbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListRecipeByCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListRecipeByCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListRecipeByCookbook(ctx, req.(*ListRecipeByCookbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListShortenRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListShortenRecipeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListShortenRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListShortenRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListShortenRecipe(ctx, req.(*ListShortenRecipeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListShortenRecipeByCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListShortenRecipeByCookbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListShortenRecipeByCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListShortenRecipeByCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListShortenRecipeByCookbook(ctx, req.(*ListShortenRecipeByCookbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/ListTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListTrade(ctx, req.(*ListTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PylonsBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PylonsBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PylonsBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Query/PylonsBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PylonsBalance(ctx, req.(*PylonsBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pylons.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddrFromPubKey",
			Handler:    _Query_AddrFromPubKey_Handler,
		},
		{
			MethodName: "CheckGoogleIAPOrder",
			Handler:    _Query_CheckGoogleIAPOrder_Handler,
		},
		{
			MethodName: "GetCookbook",
			Handler:    _Query_GetCookbook_Handler,
		},
		{
			MethodName: "GetExecution",
			Handler:    _Query_GetExecution_Handler,
		},
		{
			MethodName: "GetItem",
			Handler:    _Query_GetItem_Handler,
		},
		{
			MethodName: "GetRecipe",
			Handler:    _Query_GetRecipe_Handler,
		},
		{
			MethodName: "GetTrade",
			Handler:    _Query_GetTrade_Handler,
		},
		{
			MethodName: "ItemsByCookbook",
			Handler:    _Query_ItemsByCookbook_Handler,
		},
		{
			MethodName: "ItemsBySender",
			Handler:    _Query_ItemsBySender_Handler,
		},
		{
			MethodName: "ListCookbook",
			Handler:    _Query_ListCookbook_Handler,
		},
		{
			MethodName: "ListExecutions",
			Handler:    _Query_ListExecutions_Handler,
		},
		{
			MethodName: "GetLockedCoins",
			Handler:    _Query_GetLockedCoins_Handler,
		},
		{
			MethodName: "GetLockedCoinDetails",
			Handler:    _Query_GetLockedCoinDetails_Handler,
		},
		{
			MethodName: "ListRecipe",
			Handler:    _Query_ListRecipe_Handler,
		},
		{
			MethodName: "ListRecipeByCookbook",
			Handler:    _Query_ListRecipeByCookbook_Handler,
		},
		{
			MethodName: "ListShortenRecipe",
			Handler:    _Query_ListShortenRecipe_Handler,
		},
		{
			MethodName: "ListShortenRecipeByCookbook",
			Handler:    _Query_ListShortenRecipeByCookbook_Handler,
		},
		{
			MethodName: "ListTrade",
			Handler:    _Query_ListTrade_Handler,
		},
		{
			MethodName: "PylonsBalance",
			Handler:    _Query_PylonsBalance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pylons/query.proto",
}

func (m *AddrFromPubKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddrFromPubKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddrFromPubKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HexPubKey) > 0 {
		i -= len(m.HexPubKey)
		copy(dAtA[i:], m.HexPubKey)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.HexPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddrFromPubKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddrFromPubKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddrFromPubKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bech32Addr) > 0 {
		i -= len(m.Bech32Addr)
		copy(dAtA[i:], m.Bech32Addr)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Bech32Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckGoogleIAPOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckGoogleIAPOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckGoogleIAPOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PurchaseToken) > 0 {
		i -= len(m.PurchaseToken)
		copy(dAtA[i:], m.PurchaseToken)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PurchaseToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckGoogleIAPOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckGoogleIAPOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckGoogleIAPOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exist {
		i--
		if m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PurchaseToken) > 0 {
		i -= len(m.PurchaseToken)
		copy(dAtA[i:], m.PurchaseToken)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PurchaseToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCookbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCookbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCookbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x52
	}
	if m.CostPerBlock != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CostPerBlock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.SupportEmail) > 0 {
		i -= len(m.SupportEmail)
		copy(dAtA[i:], m.SupportEmail)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SupportEmail)))
		i--
		dAtA[i] = 0x42
	}
	if m.Level != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetExecutionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetExecutionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetExecutionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExecutionID) > 0 {
		i -= len(m.ExecutionID)
		copy(dAtA[i:], m.ExecutionID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecutionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinsInput) > 0 {
		for iNdEx := len(m.CoinsInput) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinsInput[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetRecipeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRecipeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRecipeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BlockInterval != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinInputs) > 0 {
		for iNdEx := len(m.CoinInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTradeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTradeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.FulFiller) > 0 {
		i -= len(m.FulFiller)
		copy(dAtA[i:], m.FulFiller)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FulFiller)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExtraInfo) > 0 {
		i -= len(m.ExtraInfo)
		copy(dAtA[i:], m.ExtraInfo)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExtraInfo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ItemOutputs) > 0 {
		for iNdEx := len(m.ItemOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinOutputs) > 0 {
		for iNdEx := len(m.CoinOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CoinInputs) > 0 {
		for iNdEx := len(m.CoinInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemsByCookbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsByCookbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsByCookbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemsByCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsByCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsByCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ItemsBySenderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsBySenderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsBySenderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemsBySenderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsBySenderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemsBySenderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListCookbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCookbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCookbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cookbooks) > 0 {
		for iNdEx := len(m.Cookbooks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cookbooks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListExecutionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExecutionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListExecutionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Executions) > 0 {
		for iNdEx := len(m.Executions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Executions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLockedCoinsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockedCoinsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLockedCoinsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLockedCoinsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockedCoinsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLockedCoinsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLockedCoinDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockedCoinDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLockedCoinDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLockedCoinDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockedCoinDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLockedCoinDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LockCoinExecs) > 0 {
		for iNdEx := len(m.LockCoinExecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockCoinExecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LockCoinTrades) > 0 {
		for iNdEx := len(m.LockCoinTrades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockCoinTrades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRecipeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRecipeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRecipeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for iNdEx := len(m.Recipes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListRecipeByCookbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRecipeByCookbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRecipeByCookbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRecipeByCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRecipeByCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRecipeByCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for iNdEx := len(m.Recipes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListShortenRecipeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShortenRecipeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShortenRecipeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListShortenRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShortenRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShortenRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for iNdEx := len(m.Recipes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListShortenRecipeByCookbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShortenRecipeByCookbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShortenRecipeByCookbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListShortenRecipeByCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShortenRecipeByCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShortenRecipeByCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for iNdEx := len(m.Recipes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListTradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTradeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTradeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for iNdEx := len(m.Trades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PylonsBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PylonsBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PylonsBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PylonsBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PylonsBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PylonsBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Balance != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Balance))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddrFromPubKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HexPubKey)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *AddrFromPubKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bech32Addr)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *CheckGoogleIAPOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PurchaseToken)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *CheckGoogleIAPOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PurchaseToken)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Exist {
		n += 2
	}
	return n
}

func (m *GetCookbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovQuery(uint64(m.Level))
	}
	l = len(m.SupportEmail)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.CostPerBlock != 0 {
		n += 1 + sovQuery(uint64(m.CostPerBlock))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetExecutionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecutionID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.CoinsInput) > 0 {
		for _, e := range m.CoinsInput {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Completed {
		n += 2
	}
	return n
}

func (m *GetItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Item.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *GetRecipeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.CoinInputs) > 0 {
		for _, e := range m.CoinInputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = m.Entries.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovQuery(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func (m *GetTradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.CoinInputs) > 0 {
		for _, e := range m.CoinInputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.CoinOutputs) > 0 {
		for _, e := range m.CoinOutputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ItemOutputs) > 0 {
		for _, e := range m.ItemOutputs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.ExtraInfo)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FulFiller)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if m.Completed {
		n += 2
	}
	return n
}

func (m *ItemsByCookbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ItemsByCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ItemsBySenderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ItemsBySenderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListCookbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cookbooks) > 0 {
		for _, e := range m.Cookbooks {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListExecutionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Executions) > 0 {
		for _, e := range m.Executions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *GetLockedCoinsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetLockedCoinsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *GetLockedCoinDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *GetLockedCoinDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.LockCoinTrades) > 0 {
		for _, e := range m.LockCoinTrades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.LockCoinExecs) > 0 {
		for _, e := range m.LockCoinExecs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListRecipeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for _, e := range m.Recipes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListRecipeByCookbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListRecipeByCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for _, e := range m.Recipes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListShortenRecipeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListShortenRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for _, e := range m.Recipes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListShortenRecipeByCookbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListShortenRecipeByCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Recipes) > 0 {
		for _, e := range m.Recipes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ListTradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ListTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PylonsBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *PylonsBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != 0 {
		n += 1 + sovQuery(uint64(m.Balance))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddrFromPubKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddrFromPubKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddrFromPubKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HexPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HexPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddrFromPubKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddrFromPubKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddrFromPubKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckGoogleIAPOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckGoogleIAPOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckGoogleIAPOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchaseToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckGoogleIAPOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckGoogleIAPOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckGoogleIAPOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchaseToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCookbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCookbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCookbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostPerBlock", wireType)
			}
			m.CostPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetExecutionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetExecutionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetExecutionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinsInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinsInput = append(m.CoinsInput, types.Coin{})
			if err := m.CoinsInput[len(m.CoinsInput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, Item{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRecipeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRecipeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRecipeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinInputs = append(m.CoinInputs, CoinInput{})
			if err := m.CoinInputs[len(m.CoinInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, ItemInput{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, WeightedOutputs{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinInputs = append(m.CoinInputs, CoinInput{})
			if err := m.CoinInputs[len(m.CoinInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, TradeItemInput{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinOutputs = append(m.CoinOutputs, types.Coin{})
			if err := m.CoinOutputs[len(m.CoinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemOutputs = append(m.ItemOutputs, Item{})
			if err := m.ItemOutputs[len(m.ItemOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FulFiller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FulFiller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsByCookbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsByCookbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsByCookbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsByCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsByCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsByCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsBySenderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsBySenderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsBySenderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsBySenderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsBySenderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsBySenderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCookbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCookbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCookbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookbooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookbooks = append(m.Cookbooks, Cookbook{})
			if err := m.Cookbooks[len(m.Cookbooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListExecutionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExecutionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExecutionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executions = append(m.Executions, Execution{})
			if err := m.Executions[len(m.Executions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockedCoinsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockedCoinsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockedCoinsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockedCoinsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockedCoinsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockedCoinsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockedCoinDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockedCoinDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockedCoinDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockedCoinDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockedCoinDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockedCoinDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockCoinTrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockCoinTrades = append(m.LockCoinTrades, LockedCoinDescribe{})
			if err := m.LockCoinTrades[len(m.LockCoinTrades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockCoinExecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockCoinExecs = append(m.LockCoinExecs, LockedCoinDescribe{})
			if err := m.LockCoinExecs[len(m.LockCoinExecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRecipeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRecipeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRecipeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipes = append(m.Recipes, Recipe{})
			if err := m.Recipes[len(m.Recipes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRecipeByCookbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRecipeByCookbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRecipeByCookbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRecipeByCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRecipeByCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRecipeByCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipes = append(m.Recipes, Recipe{})
			if err := m.Recipes[len(m.Recipes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShortenRecipeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShortenRecipeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShortenRecipeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShortenRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShortenRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShortenRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipes = append(m.Recipes, ShortenRecipe{})
			if err := m.Recipes[len(m.Recipes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShortenRecipeByCookbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShortenRecipeByCookbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShortenRecipeByCookbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShortenRecipeByCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShortenRecipeByCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShortenRecipeByCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipes = append(m.Recipes, ShortenRecipe{})
			if err := m.Recipes[len(m.Recipes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, Trade{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PylonsBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PylonsBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PylonsBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PylonsBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PylonsBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PylonsBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
