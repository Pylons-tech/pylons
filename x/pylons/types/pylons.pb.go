// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pylons/pylons.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EntriesList is a struct to keep list of items and coins
type EntriesList struct {
	CoinOutputs       []CoinOutput       `protobuf:"bytes,1,rep,name=CoinOutputs,proto3" json:"CoinOutputs"`
	ItemOutputs       []ItemOutput       `protobuf:"bytes,2,rep,name=ItemOutputs,proto3" json:"ItemOutputs"`
	ItemModifyOutputs []ItemModifyOutput `protobuf:"bytes,3,rep,name=ItemModifyOutputs,proto3" json:"ItemModifyOutputs"`
}

func (m *EntriesList) Reset()         { *m = EntriesList{} }
func (m *EntriesList) String() string { return proto.CompactTextString(m) }
func (*EntriesList) ProtoMessage()    {}
func (*EntriesList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{0}
}
func (m *EntriesList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesList.Merge(m, src)
}
func (m *EntriesList) XXX_Size() int {
	return m.Size()
}
func (m *EntriesList) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesList.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesList proto.InternalMessageInfo

func (m *EntriesList) GetCoinOutputs() []CoinOutput {
	if m != nil {
		return m.CoinOutputs
	}
	return nil
}

func (m *EntriesList) GetItemOutputs() []ItemOutput {
	if m != nil {
		return m.ItemOutputs
	}
	return nil
}

func (m *EntriesList) GetItemModifyOutputs() []ItemModifyOutput {
	if m != nil {
		return m.ItemModifyOutputs
	}
	return nil
}

type CoinInput struct {
	Coin  string `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Count int64  `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *CoinInput) Reset()         { *m = CoinInput{} }
func (m *CoinInput) String() string { return proto.CompactTextString(m) }
func (*CoinInput) ProtoMessage()    {}
func (*CoinInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{1}
}
func (m *CoinInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinInput.Merge(m, src)
}
func (m *CoinInput) XXX_Size() int {
	return m.Size()
}
func (m *CoinInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinInput.DiscardUnknown(m)
}

var xxx_messageInfo_CoinInput proto.InternalMessageInfo

func (m *CoinInput) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CoinInput) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type CoinOutput struct {
	ID    string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Coin  string `protobuf:"bytes,2,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Count string `protobuf:"bytes,3,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *CoinOutput) Reset()         { *m = CoinOutput{} }
func (m *CoinOutput) String() string { return proto.CompactTextString(m) }
func (*CoinOutput) ProtoMessage()    {}
func (*CoinOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{2}
}
func (m *CoinOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinOutput.Merge(m, src)
}
func (m *CoinOutput) XXX_Size() int {
	return m.Size()
}
func (m *CoinOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinOutput.DiscardUnknown(m)
}

var xxx_messageInfo_CoinOutput proto.InternalMessageInfo

func (m *CoinOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *CoinOutput) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CoinOutput) GetCount() string {
	if m != nil {
		return m.Count
	}
	return ""
}

// DoubleInputParam describes the bounds on an item input/output parameter of type float64
type DoubleInputParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The minimum legal value of this parameter.
	MinValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=MinValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"MinValue"`
	// The maximum legal value of this parameter.
	MaxValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=MaxValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"MaxValue"`
}

func (m *DoubleInputParam) Reset()         { *m = DoubleInputParam{} }
func (m *DoubleInputParam) String() string { return proto.CompactTextString(m) }
func (*DoubleInputParam) ProtoMessage()    {}
func (*DoubleInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{3}
}
func (m *DoubleInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleInputParam.Merge(m, src)
}
func (m *DoubleInputParam) XXX_Size() int {
	return m.Size()
}
func (m *DoubleInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleInputParam proto.InternalMessageInfo

func (m *DoubleInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// DoubleWeightRange describes weight range that produce double value
type DoubleWeightRange struct {
	Lower  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=Lower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Lower"`
	Upper  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=Upper,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Upper"`
	Weight int64                                  `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *DoubleWeightRange) Reset()         { *m = DoubleWeightRange{} }
func (m *DoubleWeightRange) String() string { return proto.CompactTextString(m) }
func (*DoubleWeightRange) ProtoMessage()    {}
func (*DoubleWeightRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{4}
}
func (m *DoubleWeightRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleWeightRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleWeightRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleWeightRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleWeightRange.Merge(m, src)
}
func (m *DoubleWeightRange) XXX_Size() int {
	return m.Size()
}
func (m *DoubleWeightRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleWeightRange.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleWeightRange proto.InternalMessageInfo

func (m *DoubleWeightRange) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type DoubleWeightTable struct {
	WeightRanges []DoubleWeightRange `protobuf:"bytes,1,rep,name=WeightRanges,proto3" json:"WeightRanges"`
}

func (m *DoubleWeightTable) Reset()         { *m = DoubleWeightTable{} }
func (m *DoubleWeightTable) String() string { return proto.CompactTextString(m) }
func (*DoubleWeightTable) ProtoMessage()    {}
func (*DoubleWeightTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{5}
}
func (m *DoubleWeightTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleWeightTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleWeightTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleWeightTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleWeightTable.Merge(m, src)
}
func (m *DoubleWeightTable) XXX_Size() int {
	return m.Size()
}
func (m *DoubleWeightTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleWeightTable.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleWeightTable proto.InternalMessageInfo

func (m *DoubleWeightTable) GetWeightRanges() []DoubleWeightRange {
	if m != nil {
		return m.WeightRanges
	}
	return nil
}

// LongParam describes the bounds on an item input/output parameter of type int64
type LongParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate        github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=Rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Rate"`
	WeightTable IntWeightTable                         `protobuf:"bytes,3,opt,name=WeightTable,proto3" json:"WeightTable"`
	// When program is not empty, IntWeightTable is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *LongParam) Reset()         { *m = LongParam{} }
func (m *LongParam) String() string { return proto.CompactTextString(m) }
func (*LongParam) ProtoMessage()    {}
func (*LongParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{6}
}
func (m *LongParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongParam.Merge(m, src)
}
func (m *LongParam) XXX_Size() int {
	return m.Size()
}
func (m *LongParam) XXX_DiscardUnknown() {
	xxx_messageInfo_LongParam.DiscardUnknown(m)
}

var xxx_messageInfo_LongParam proto.InternalMessageInfo

func (m *LongParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongParam) GetWeightTable() IntWeightTable {
	if m != nil {
		return m.WeightTable
	}
	return IntWeightTable{}
}

func (m *LongParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// IntWeightRange describes weight range that produce int value
type IntWeightRange struct {
	Lower  int64 `protobuf:"varint,1,opt,name=Lower,proto3" json:"Lower,omitempty"`
	Upper  int64 `protobuf:"varint,2,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Weight int64 `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *IntWeightRange) Reset()         { *m = IntWeightRange{} }
func (m *IntWeightRange) String() string { return proto.CompactTextString(m) }
func (*IntWeightRange) ProtoMessage()    {}
func (*IntWeightRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{7}
}
func (m *IntWeightRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntWeightRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntWeightRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntWeightRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntWeightRange.Merge(m, src)
}
func (m *IntWeightRange) XXX_Size() int {
	return m.Size()
}
func (m *IntWeightRange) XXX_DiscardUnknown() {
	xxx_messageInfo_IntWeightRange.DiscardUnknown(m)
}

var xxx_messageInfo_IntWeightRange proto.InternalMessageInfo

func (m *IntWeightRange) GetLower() int64 {
	if m != nil {
		return m.Lower
	}
	return 0
}

func (m *IntWeightRange) GetUpper() int64 {
	if m != nil {
		return m.Upper
	}
	return 0
}

func (m *IntWeightRange) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// IntWeightTable describes weight loot table that produce int value
type IntWeightTable struct {
	WeightRanges []IntWeightRange `protobuf:"bytes,1,rep,name=WeightRanges,proto3" json:"WeightRanges"`
}

func (m *IntWeightTable) Reset()         { *m = IntWeightTable{} }
func (m *IntWeightTable) String() string { return proto.CompactTextString(m) }
func (*IntWeightTable) ProtoMessage()    {}
func (*IntWeightTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{8}
}
func (m *IntWeightTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntWeightTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntWeightTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntWeightTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntWeightTable.Merge(m, src)
}
func (m *IntWeightTable) XXX_Size() int {
	return m.Size()
}
func (m *IntWeightTable) XXX_DiscardUnknown() {
	xxx_messageInfo_IntWeightTable.DiscardUnknown(m)
}

var xxx_messageInfo_IntWeightTable proto.InternalMessageInfo

func (m *IntWeightTable) GetWeightRanges() []IntWeightRange {
	if m != nil {
		return m.WeightRanges
	}
	return nil
}

// StringInputParam describes the bounds on an item input/output parameter of type string
type StringInputParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The value of the parameter
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *StringInputParam) Reset()         { *m = StringInputParam{} }
func (m *StringInputParam) String() string { return proto.CompactTextString(m) }
func (*StringInputParam) ProtoMessage()    {}
func (*StringInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{9}
}
func (m *StringInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringInputParam.Merge(m, src)
}
func (m *StringInputParam) XXX_Size() int {
	return m.Size()
}
func (m *StringInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_StringInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_StringInputParam proto.InternalMessageInfo

func (m *StringInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringInputParam) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type FeeInputParam struct {
	MinValue int64 `protobuf:"varint,1,opt,name=MinValue,proto3" json:"MinValue,omitempty"`
	MaxValue int64 `protobuf:"varint,2,opt,name=MaxValue,proto3" json:"MaxValue,omitempty"`
}

func (m *FeeInputParam) Reset()         { *m = FeeInputParam{} }
func (m *FeeInputParam) String() string { return proto.CompactTextString(m) }
func (*FeeInputParam) ProtoMessage()    {}
func (*FeeInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{10}
}
func (m *FeeInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeInputParam.Merge(m, src)
}
func (m *FeeInputParam) XXX_Size() int {
	return m.Size()
}
func (m *FeeInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_FeeInputParam proto.InternalMessageInfo

func (m *FeeInputParam) GetMinValue() int64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *FeeInputParam) GetMaxValue() int64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

// LongInputParam describes the bounds on an item input/output parameter of type int64
type LongInputParam struct {
	Key      string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	MinValue int64  `protobuf:"varint,2,opt,name=MinValue,proto3" json:"MinValue,omitempty"`
	MaxValue int64  `protobuf:"varint,3,opt,name=MaxValue,proto3" json:"MaxValue,omitempty"`
}

func (m *LongInputParam) Reset()         { *m = LongInputParam{} }
func (m *LongInputParam) String() string { return proto.CompactTextString(m) }
func (*LongInputParam) ProtoMessage()    {}
func (*LongInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{11}
}
func (m *LongInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongInputParam.Merge(m, src)
}
func (m *LongInputParam) XXX_Size() int {
	return m.Size()
}
func (m *LongInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_LongInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_LongInputParam proto.InternalMessageInfo

func (m *LongInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongInputParam) GetMinValue() int64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *LongInputParam) GetMaxValue() int64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

// ConditionList is a struct for describing  ItemInput expression conditions
type ConditionList struct {
	Doubles []DoubleInputParam `protobuf:"bytes,1,rep,name=Doubles,proto3" json:"Doubles"`
	Longs   []LongInputParam   `protobuf:"bytes,2,rep,name=Longs,proto3" json:"Longs"`
	Strings []StringInputParam `protobuf:"bytes,3,rep,name=Strings,proto3" json:"Strings"`
}

func (m *ConditionList) Reset()         { *m = ConditionList{} }
func (m *ConditionList) String() string { return proto.CompactTextString(m) }
func (*ConditionList) ProtoMessage()    {}
func (*ConditionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{12}
}
func (m *ConditionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionList.Merge(m, src)
}
func (m *ConditionList) XXX_Size() int {
	return m.Size()
}
func (m *ConditionList) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionList.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionList proto.InternalMessageInfo

func (m *ConditionList) GetDoubles() []DoubleInputParam {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ConditionList) GetLongs() []LongInputParam {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ConditionList) GetStrings() []StringInputParam {
	if m != nil {
		return m.Strings
	}
	return nil
}

// ItemInput is a wrapper struct for Item for recipes
type ItemInput struct {
	ID          string             `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles     []DoubleInputParam `protobuf:"bytes,2,rep,name=Doubles,proto3" json:"Doubles"`
	Longs       []LongInputParam   `protobuf:"bytes,3,rep,name=Longs,proto3" json:"Longs"`
	Strings     []StringInputParam `protobuf:"bytes,4,rep,name=Strings,proto3" json:"Strings"`
	TransferFee FeeInputParam      `protobuf:"bytes,5,opt,name=TransferFee,proto3" json:"TransferFee"`
	Conditions  ConditionList      `protobuf:"bytes,6,opt,name=Conditions,proto3" json:"Conditions"`
}

func (m *ItemInput) Reset()         { *m = ItemInput{} }
func (m *ItemInput) String() string { return proto.CompactTextString(m) }
func (*ItemInput) ProtoMessage()    {}
func (*ItemInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{13}
}
func (m *ItemInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemInput.Merge(m, src)
}
func (m *ItemInput) XXX_Size() int {
	return m.Size()
}
func (m *ItemInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemInput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemInput proto.InternalMessageInfo

func (m *ItemInput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemInput) GetDoubles() []DoubleInputParam {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemInput) GetLongs() []LongInputParam {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemInput) GetStrings() []StringInputParam {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemInput) GetTransferFee() FeeInputParam {
	if m != nil {
		return m.TransferFee
	}
	return FeeInputParam{}
}

func (m *ItemInput) GetConditions() ConditionList {
	if m != nil {
		return m.Conditions
	}
	return ConditionList{}
}

// WeightedOutputs is to make structs which is using weight to be based on
type WeightedOutputs struct {
	EntryIDs []string `protobuf:"bytes,1,rep,name=EntryIDs,proto3" json:"EntryIDs,omitempty"`
	Weight   string   `protobuf:"bytes,2,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *WeightedOutputs) Reset()         { *m = WeightedOutputs{} }
func (m *WeightedOutputs) String() string { return proto.CompactTextString(m) }
func (*WeightedOutputs) ProtoMessage()    {}
func (*WeightedOutputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{14}
}
func (m *WeightedOutputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedOutputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedOutputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedOutputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedOutputs.Merge(m, src)
}
func (m *WeightedOutputs) XXX_Size() int {
	return m.Size()
}
func (m *WeightedOutputs) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedOutputs.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedOutputs proto.InternalMessageInfo

func (m *WeightedOutputs) GetEntryIDs() []string {
	if m != nil {
		return m.EntryIDs
	}
	return nil
}

func (m *WeightedOutputs) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

// StringParam describes an item input/output parameter of type string
type StringParam struct {
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=Rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Rate"`
	Key   string                                 `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string                                 `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
	// When program is not empty, Value is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *StringParam) Reset()         { *m = StringParam{} }
func (m *StringParam) String() string { return proto.CompactTextString(m) }
func (*StringParam) ProtoMessage()    {}
func (*StringParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{15}
}
func (m *StringParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringParam.Merge(m, src)
}
func (m *StringParam) XXX_Size() int {
	return m.Size()
}
func (m *StringParam) XXX_DiscardUnknown() {
	xxx_messageInfo_StringParam.DiscardUnknown(m)
}

var xxx_messageInfo_StringParam proto.InternalMessageInfo

func (m *StringParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringParam) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StringParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// DoubleParam describes the bounds on an item input/output parameter of type float64
type DoubleParam struct {
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate        github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=Rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Rate"`
	Key         string                                 `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	WeightTable DoubleWeightTable                      `protobuf:"bytes,3,opt,name=WeightTable,proto3" json:"WeightTable"`
	// When program is not empty, DoubleWeightTable is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *DoubleParam) Reset()         { *m = DoubleParam{} }
func (m *DoubleParam) String() string { return proto.CompactTextString(m) }
func (*DoubleParam) ProtoMessage()    {}
func (*DoubleParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{16}
}
func (m *DoubleParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleParam.Merge(m, src)
}
func (m *DoubleParam) XXX_Size() int {
	return m.Size()
}
func (m *DoubleParam) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleParam.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleParam proto.InternalMessageInfo

func (m *DoubleParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DoubleParam) GetWeightTable() DoubleWeightTable {
	if m != nil {
		return m.WeightTable
	}
	return DoubleWeightTable{}
}

func (m *DoubleParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// ItemOutput models the continuum of valid outcomes for item generation in recipes
type ItemOutput struct {
	ID          string        `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles     []DoubleParam `protobuf:"bytes,2,rep,name=Doubles,proto3" json:"Doubles"`
	Longs       []LongParam   `protobuf:"bytes,3,rep,name=Longs,proto3" json:"Longs"`
	Strings     []StringParam `protobuf:"bytes,4,rep,name=Strings,proto3" json:"Strings"`
	TransferFee int64         `protobuf:"varint,5,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemOutput) Reset()         { *m = ItemOutput{} }
func (m *ItemOutput) String() string { return proto.CompactTextString(m) }
func (*ItemOutput) ProtoMessage()    {}
func (*ItemOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{17}
}
func (m *ItemOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemOutput.Merge(m, src)
}
func (m *ItemOutput) XXX_Size() int {
	return m.Size()
}
func (m *ItemOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemOutput proto.InternalMessageInfo

func (m *ItemOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemOutput) GetDoubles() []DoubleParam {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemOutput) GetLongs() []LongParam {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemOutput) GetStrings() []StringParam {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemOutput) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// ItemModifyOutput describes what is modified from item input
type ItemModifyOutput struct {
	ID           string        `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ItemInputRef string        `protobuf:"bytes,2,opt,name=ItemInputRef,proto3" json:"ItemInputRef,omitempty"`
	Doubles      []DoubleParam `protobuf:"bytes,3,rep,name=Doubles,proto3" json:"Doubles"`
	Longs        []LongParam   `protobuf:"bytes,4,rep,name=Longs,proto3" json:"Longs"`
	Strings      []StringParam `protobuf:"bytes,5,rep,name=Strings,proto3" json:"Strings"`
	TransferFee  int64         `protobuf:"varint,6,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemModifyOutput) Reset()         { *m = ItemModifyOutput{} }
func (m *ItemModifyOutput) String() string { return proto.CompactTextString(m) }
func (*ItemModifyOutput) ProtoMessage()    {}
func (*ItemModifyOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{18}
}
func (m *ItemModifyOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemModifyOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemModifyOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemModifyOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemModifyOutput.Merge(m, src)
}
func (m *ItemModifyOutput) XXX_Size() int {
	return m.Size()
}
func (m *ItemModifyOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemModifyOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemModifyOutput proto.InternalMessageInfo

func (m *ItemModifyOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemModifyOutput) GetItemInputRef() string {
	if m != nil {
		return m.ItemInputRef
	}
	return ""
}

func (m *ItemModifyOutput) GetDoubles() []DoubleParam {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemModifyOutput) GetLongs() []LongParam {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemModifyOutput) GetStrings() []StringParam {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemModifyOutput) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// ItemModifyParams describes the fields that needs to be modified
type ItemModifyParams struct {
	Doubles     []DoubleParam `protobuf:"bytes,1,rep,name=Doubles,proto3" json:"Doubles"`
	Longs       []LongParam   `protobuf:"bytes,2,rep,name=Longs,proto3" json:"Longs"`
	Strings     []StringParam `protobuf:"bytes,3,rep,name=Strings,proto3" json:"Strings"`
	TransferFee int64         `protobuf:"varint,4,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemModifyParams) Reset()         { *m = ItemModifyParams{} }
func (m *ItemModifyParams) String() string { return proto.CompactTextString(m) }
func (*ItemModifyParams) ProtoMessage()    {}
func (*ItemModifyParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{19}
}
func (m *ItemModifyParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemModifyParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemModifyParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemModifyParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemModifyParams.Merge(m, src)
}
func (m *ItemModifyParams) XXX_Size() int {
	return m.Size()
}
func (m *ItemModifyParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemModifyParams.DiscardUnknown(m)
}

var xxx_messageInfo_ItemModifyParams proto.InternalMessageInfo

func (m *ItemModifyParams) GetDoubles() []DoubleParam {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemModifyParams) GetLongs() []LongParam {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemModifyParams) GetStrings() []StringParam {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemModifyParams) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// Item is a tradable asset
type Item struct {
	NodeVersion   string           `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID            string           `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles       []DoubleKeyValue `protobuf:"bytes,3,rep,name=Doubles,proto3" json:"Doubles"`
	Longs         []LongKeyValue   `protobuf:"bytes,4,rep,name=Longs,proto3" json:"Longs"`
	Strings       []StringKeyValue `protobuf:"bytes,5,rep,name=Strings,proto3" json:"Strings"`
	CookbookID    string           `protobuf:"bytes,6,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Sender        string           `protobuf:"bytes,7,opt,name=Sender,proto3" json:"Sender,omitempty"`
	OwnerRecipeID string           `protobuf:"bytes,8,opt,name=OwnerRecipeID,proto3" json:"OwnerRecipeID,omitempty"`
	OwnerTradeID  string           `protobuf:"bytes,9,opt,name=OwnerTradeID,proto3" json:"OwnerTradeID,omitempty"`
	Tradable      bool             `protobuf:"varint,10,opt,name=Tradable,proto3" json:"Tradable,omitempty"`
	LastUpdate    int64            `protobuf:"varint,11,opt,name=LastUpdate,proto3" json:"LastUpdate,omitempty"`
	TransferFee   int64            `protobuf:"varint,12,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{20}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *Item) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Item) GetDoubles() []DoubleKeyValue {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *Item) GetLongs() []LongKeyValue {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *Item) GetStrings() []StringKeyValue {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Item) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *Item) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Item) GetOwnerRecipeID() string {
	if m != nil {
		return m.OwnerRecipeID
	}
	return ""
}

func (m *Item) GetOwnerTradeID() string {
	if m != nil {
		return m.OwnerTradeID
	}
	return ""
}

func (m *Item) GetTradable() bool {
	if m != nil {
		return m.Tradable
	}
	return false
}

func (m *Item) GetLastUpdate() int64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Item) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// DoubleKeyValue describes double key/value set
type DoubleKeyValue struct {
	Key   string                                 `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=Value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"Value"`
}

func (m *DoubleKeyValue) Reset()         { *m = DoubleKeyValue{} }
func (m *DoubleKeyValue) String() string { return proto.CompactTextString(m) }
func (*DoubleKeyValue) ProtoMessage()    {}
func (*DoubleKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{21}
}
func (m *DoubleKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleKeyValue.Merge(m, src)
}
func (m *DoubleKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *DoubleKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleKeyValue proto.InternalMessageInfo

func (m *DoubleKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// LongKeyValue describes long key/value set
type LongKeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LongKeyValue) Reset()         { *m = LongKeyValue{} }
func (m *LongKeyValue) String() string { return proto.CompactTextString(m) }
func (*LongKeyValue) ProtoMessage()    {}
func (*LongKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{22}
}
func (m *LongKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongKeyValue.Merge(m, src)
}
func (m *LongKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *LongKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LongKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_LongKeyValue proto.InternalMessageInfo

func (m *LongKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongKeyValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// StringKeyValue describes string key/value set
type StringKeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *StringKeyValue) Reset()         { *m = StringKeyValue{} }
func (m *StringKeyValue) String() string { return proto.CompactTextString(m) }
func (*StringKeyValue) ProtoMessage()    {}
func (*StringKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{23}
}
func (m *StringKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringKeyValue.Merge(m, src)
}
func (m *StringKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *StringKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_StringKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_StringKeyValue proto.InternalMessageInfo

func (m *StringKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringKeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TradeItemInput is a wrapper struct for Item for trades
type TradeItemInput struct {
	ItemInput  ItemInput `protobuf:"bytes,1,opt,name=ItemInput,proto3" json:"ItemInput"`
	CookbookID string    `protobuf:"bytes,2,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
}

func (m *TradeItemInput) Reset()         { *m = TradeItemInput{} }
func (m *TradeItemInput) String() string { return proto.CompactTextString(m) }
func (*TradeItemInput) ProtoMessage()    {}
func (*TradeItemInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{24}
}
func (m *TradeItemInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeItemInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeItemInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeItemInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeItemInput.Merge(m, src)
}
func (m *TradeItemInput) XXX_Size() int {
	return m.Size()
}
func (m *TradeItemInput) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeItemInput.DiscardUnknown(m)
}

var xxx_messageInfo_TradeItemInput proto.InternalMessageInfo

func (m *TradeItemInput) GetItemInput() ItemInput {
	if m != nil {
		return m.ItemInput
	}
	return ItemInput{}
}

func (m *TradeItemInput) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

// LockedCoinDescribe describes the locked coin struct
type LockedCoinDescribe struct {
	ID     string                                   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
}

func (m *LockedCoinDescribe) Reset()         { *m = LockedCoinDescribe{} }
func (m *LockedCoinDescribe) String() string { return proto.CompactTextString(m) }
func (*LockedCoinDescribe) ProtoMessage()    {}
func (*LockedCoinDescribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{25}
}
func (m *LockedCoinDescribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockedCoinDescribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockedCoinDescribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockedCoinDescribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockedCoinDescribe.Merge(m, src)
}
func (m *LockedCoinDescribe) XXX_Size() int {
	return m.Size()
}
func (m *LockedCoinDescribe) XXX_DiscardUnknown() {
	xxx_messageInfo_LockedCoinDescribe.DiscardUnknown(m)
}

var xxx_messageInfo_LockedCoinDescribe proto.InternalMessageInfo

func (m *LockedCoinDescribe) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *LockedCoinDescribe) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// ShortenRecipe is a struct to manage shorten recipes
type ShortenRecipe struct {
	ID          string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CookbookID  string `protobuf:"bytes,2,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	Sender      string `protobuf:"bytes,5,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *ShortenRecipe) Reset()         { *m = ShortenRecipe{} }
func (m *ShortenRecipe) String() string { return proto.CompactTextString(m) }
func (*ShortenRecipe) ProtoMessage()    {}
func (*ShortenRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{26}
}
func (m *ShortenRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShortenRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShortenRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShortenRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShortenRecipe.Merge(m, src)
}
func (m *ShortenRecipe) XXX_Size() int {
	return m.Size()
}
func (m *ShortenRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_ShortenRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_ShortenRecipe proto.InternalMessageInfo

func (m *ShortenRecipe) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ShortenRecipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *ShortenRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ShortenRecipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ShortenRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type Execution struct {
	NodeVersion string                                   `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID          string                                   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	RecipeID    string                                   `protobuf:"bytes,3,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	CookbookID  string                                   `protobuf:"bytes,4,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	CoinInputs  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=CoinInputs,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinInputs"`
	ItemInputs  []Item                                   `protobuf:"bytes,6,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	BlockHeight int64                                    `protobuf:"varint,7,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Sender      string                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Completed   bool                                     `protobuf:"varint,9,opt,name=Completed,proto3" json:"Completed,omitempty"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{27}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *Execution) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Execution) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *Execution) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *Execution) GetCoinInputs() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *Execution) GetItemInputs() []Item {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *Execution) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *Execution) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Execution) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

type Cookbook struct {
	NodeVersion  string `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID           string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Name         string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Description  string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      string `protobuf:"bytes,5,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string `protobuf:"bytes,6,opt,name=Developer,proto3" json:"Developer,omitempty"`
	Level        int64  `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
	SupportEmail string `protobuf:"bytes,8,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	CostPerBlock int64  `protobuf:"varint,9,opt,name=CostPerBlock,proto3" json:"CostPerBlock,omitempty"`
	Sender       string `protobuf:"bytes,10,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *Cookbook) Reset()         { *m = Cookbook{} }
func (m *Cookbook) String() string { return proto.CompactTextString(m) }
func (*Cookbook) ProtoMessage()    {}
func (*Cookbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{28}
}
func (m *Cookbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cookbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cookbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cookbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cookbook.Merge(m, src)
}
func (m *Cookbook) XXX_Size() int {
	return m.Size()
}
func (m *Cookbook) XXX_DiscardUnknown() {
	xxx_messageInfo_Cookbook.DiscardUnknown(m)
}

var xxx_messageInfo_Cookbook proto.InternalMessageInfo

func (m *Cookbook) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *Cookbook) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Cookbook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cookbook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Cookbook) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Cookbook) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *Cookbook) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Cookbook) GetSupportEmail() string {
	if m != nil {
		return m.SupportEmail
	}
	return ""
}

func (m *Cookbook) GetCostPerBlock() int64 {
	if m != nil {
		return m.CostPerBlock
	}
	return 0
}

func (m *Cookbook) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type Recipe struct {
	NodeVersion   string            `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID            string            `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	CookbookID    string            `protobuf:"bytes,3,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Name          string            `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	CoinInputs    []CoinInput       `protobuf:"bytes,5,rep,name=CoinInputs,proto3" json:"CoinInputs"`
	ItemInputs    []ItemInput       `protobuf:"bytes,6,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	Entries       EntriesList       `protobuf:"bytes,7,opt,name=Entries,proto3" json:"Entries"`
	Outputs       []WeightedOutputs `protobuf:"bytes,8,rep,name=Outputs,proto3" json:"Outputs"`
	Description   string            `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	BlockInterval int64             `protobuf:"varint,10,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string            `protobuf:"bytes,11,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Disabled      bool              `protobuf:"varint,12,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
	ExtraInfo     string            `protobuf:"bytes,13,opt,name=ExtraInfo,proto3" json:"ExtraInfo,omitempty"`
}

func (m *Recipe) Reset()         { *m = Recipe{} }
func (m *Recipe) String() string { return proto.CompactTextString(m) }
func (*Recipe) ProtoMessage()    {}
func (*Recipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{29}
}
func (m *Recipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recipe.Merge(m, src)
}
func (m *Recipe) XXX_Size() int {
	return m.Size()
}
func (m *Recipe) XXX_DiscardUnknown() {
	xxx_messageInfo_Recipe.DiscardUnknown(m)
}

var xxx_messageInfo_Recipe proto.InternalMessageInfo

func (m *Recipe) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *Recipe) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Recipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *Recipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Recipe) GetCoinInputs() []CoinInput {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *Recipe) GetItemInputs() []ItemInput {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *Recipe) GetEntries() EntriesList {
	if m != nil {
		return m.Entries
	}
	return EntriesList{}
}

func (m *Recipe) GetOutputs() []WeightedOutputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Recipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Recipe) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *Recipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Recipe) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *Recipe) GetExtraInfo() string {
	if m != nil {
		return m.ExtraInfo
	}
	return ""
}

type Trade struct {
	NodeVersion string                                   `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID          string                                   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	CoinInputs  []CoinInput                              `protobuf:"bytes,3,rep,name=CoinInputs,proto3" json:"CoinInputs"`
	ItemInputs  []TradeItemInput                         `protobuf:"bytes,4,rep,name=ItemInputs,proto3" json:"ItemInputs"`
	CoinOutputs github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=CoinOutputs,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinOutputs"`
	ItemOutputs []Item                                   `protobuf:"bytes,6,rep,name=ItemOutputs,proto3" json:"ItemOutputs"`
	ExtraInfo   string                                   `protobuf:"bytes,7,opt,name=ExtraInfo,proto3" json:"ExtraInfo,omitempty"`
	Sender      string                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	FulFiller   string                                   `protobuf:"bytes,9,opt,name=FulFiller,proto3" json:"FulFiller,omitempty"`
	Disabled    bool                                     `protobuf:"varint,10,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
	Completed   bool                                     `protobuf:"varint,11,opt,name=Completed,proto3" json:"Completed,omitempty"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_f39a401e48d8a838, []int{30}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (m *Trade) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Trade) GetCoinInputs() []CoinInput {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *Trade) GetItemInputs() []TradeItemInput {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *Trade) GetCoinOutputs() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinOutputs
	}
	return nil
}

func (m *Trade) GetItemOutputs() []Item {
	if m != nil {
		return m.ItemOutputs
	}
	return nil
}

func (m *Trade) GetExtraInfo() string {
	if m != nil {
		return m.ExtraInfo
	}
	return ""
}

func (m *Trade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Trade) GetFulFiller() string {
	if m != nil {
		return m.FulFiller
	}
	return ""
}

func (m *Trade) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *Trade) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func init() {
	proto.RegisterType((*EntriesList)(nil), "pylons.EntriesList")
	proto.RegisterType((*CoinInput)(nil), "pylons.CoinInput")
	proto.RegisterType((*CoinOutput)(nil), "pylons.CoinOutput")
	proto.RegisterType((*DoubleInputParam)(nil), "pylons.DoubleInputParam")
	proto.RegisterType((*DoubleWeightRange)(nil), "pylons.DoubleWeightRange")
	proto.RegisterType((*DoubleWeightTable)(nil), "pylons.DoubleWeightTable")
	proto.RegisterType((*LongParam)(nil), "pylons.LongParam")
	proto.RegisterType((*IntWeightRange)(nil), "pylons.IntWeightRange")
	proto.RegisterType((*IntWeightTable)(nil), "pylons.IntWeightTable")
	proto.RegisterType((*StringInputParam)(nil), "pylons.StringInputParam")
	proto.RegisterType((*FeeInputParam)(nil), "pylons.FeeInputParam")
	proto.RegisterType((*LongInputParam)(nil), "pylons.LongInputParam")
	proto.RegisterType((*ConditionList)(nil), "pylons.ConditionList")
	proto.RegisterType((*ItemInput)(nil), "pylons.ItemInput")
	proto.RegisterType((*WeightedOutputs)(nil), "pylons.WeightedOutputs")
	proto.RegisterType((*StringParam)(nil), "pylons.StringParam")
	proto.RegisterType((*DoubleParam)(nil), "pylons.DoubleParam")
	proto.RegisterType((*ItemOutput)(nil), "pylons.ItemOutput")
	proto.RegisterType((*ItemModifyOutput)(nil), "pylons.ItemModifyOutput")
	proto.RegisterType((*ItemModifyParams)(nil), "pylons.ItemModifyParams")
	proto.RegisterType((*Item)(nil), "pylons.Item")
	proto.RegisterType((*DoubleKeyValue)(nil), "pylons.DoubleKeyValue")
	proto.RegisterType((*LongKeyValue)(nil), "pylons.LongKeyValue")
	proto.RegisterType((*StringKeyValue)(nil), "pylons.StringKeyValue")
	proto.RegisterType((*TradeItemInput)(nil), "pylons.TradeItemInput")
	proto.RegisterType((*LockedCoinDescribe)(nil), "pylons.LockedCoinDescribe")
	proto.RegisterType((*ShortenRecipe)(nil), "pylons.ShortenRecipe")
	proto.RegisterType((*Execution)(nil), "pylons.Execution")
	proto.RegisterType((*Cookbook)(nil), "pylons.Cookbook")
	proto.RegisterType((*Recipe)(nil), "pylons.Recipe")
	proto.RegisterType((*Trade)(nil), "pylons.Trade")
}

func init() { proto.RegisterFile("pylons/pylons.proto", fileDescriptor_f39a401e48d8a838) }

var fileDescriptor_f39a401e48d8a838 = []byte{
	// 1619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xee, 0x3a, 0xfe, 0x78, 0x4e, 0x42, 0xb2, 0x0d, 0x61, 0xb1, 0x90, 0x1b, 0xad, 0x2a,
	0x94, 0x03, 0xb5, 0xdb, 0x84, 0x7e, 0xa8, 0x7c, 0x88, 0x26, 0x4e, 0xc0, 0x34, 0x6d, 0xa3, 0x4d,
	0x5a, 0x50, 0x6f, 0x6b, 0x7b, 0xe2, 0xac, 0x62, 0xef, 0xac, 0x76, 0xd7, 0x6d, 0x72, 0xe4, 0xc8,
	0x01, 0x09, 0x89, 0x7f, 0x80, 0x33, 0xff, 0x40, 0x25, 0x40, 0x82, 0x63, 0x2f, 0x48, 0x95, 0x38,
	0x80, 0x38, 0x14, 0xd4, 0x5c, 0x38, 0xf3, 0x17, 0xa0, 0xf9, 0x5a, 0xcf, 0xec, 0x3a, 0x69, 0x6d,
	0xe8, 0xc9, 0x9e, 0xb7, 0xf3, 0xde, 0xcc, 0xef, 0xbd, 0xdf, 0x7b, 0xf3, 0x66, 0xe0, 0x5c, 0x70,
	0xdc, 0xc3, 0x7e, 0x54, 0x67, 0x3f, 0xb5, 0x20, 0xc4, 0x31, 0x36, 0xf3, 0x6c, 0x54, 0x59, 0xec,
	0xe2, 0x2e, 0xa6, 0xa2, 0x3a, 0xf9, 0xc7, 0xbe, 0x56, 0xaa, 0x6d, 0x1c, 0xf5, 0x71, 0x54, 0x6f,
	0xb9, 0x11, 0xaa, 0x3f, 0xbc, 0xdc, 0x42, 0xb1, 0x7b, 0xb9, 0xde, 0xc6, 0x9e, 0xcf, 0xbe, 0xdb,
	0xbf, 0x6a, 0x50, 0xde, 0xf4, 0xe3, 0xd0, 0x43, 0xd1, 0xb6, 0x17, 0xc5, 0xe6, 0x0d, 0x28, 0x6f,
	0x60, 0xcf, 0xbf, 0x3b, 0x88, 0x83, 0x41, 0x1c, 0x59, 0xda, 0xb2, 0xb1, 0x52, 0x5e, 0x35, 0x6b,
	0x7c, 0xc5, 0xe1, 0xa7, 0xf5, 0xdc, 0x93, 0x67, 0xe7, 0xa7, 0x1c, 0x79, 0x32, 0xd1, 0x6d, 0xc6,
	0xa8, 0x2f, 0x74, 0x75, 0x55, 0x77, 0xf8, 0x49, 0xe8, 0x4a, 0x93, 0xcd, 0x6d, 0x58, 0x20, 0xc3,
	0xdb, 0xb8, 0xe3, 0xed, 0x1f, 0x0b, 0x0b, 0x06, 0xb5, 0x60, 0xc9, 0x16, 0xe4, 0x09, 0xdc, 0x4e,
	0x56, 0xd1, 0xbe, 0x02, 0x25, 0xb2, 0xb1, 0xa6, 0x1f, 0x0c, 0x62, 0xd3, 0x84, 0x1c, 0x19, 0x58,
	0xda, 0xb2, 0xb6, 0x52, 0x72, 0xe8, 0x7f, 0x73, 0x11, 0xa6, 0x37, 0xf0, 0xc0, 0x8f, 0x2d, 0x7d,
	0x59, 0x5b, 0x31, 0x1c, 0x36, 0xb0, 0xb7, 0x00, 0x86, 0x78, 0xcc, 0x39, 0xd0, 0x9b, 0x0d, 0xae,
	0xa5, 0x37, 0x1b, 0x89, 0x1d, 0x7d, 0x94, 0x1d, 0x83, 0x0a, 0xb9, 0x9d, 0x1f, 0x35, 0x98, 0x6f,
	0xe0, 0x41, 0xab, 0x87, 0xe8, 0x0e, 0x76, 0xdc, 0xd0, 0xed, 0x9b, 0xf3, 0x60, 0xdc, 0x42, 0xc7,
	0xdc, 0x1e, 0xf9, 0x6b, 0x7e, 0x0a, 0xc5, 0xdb, 0x9e, 0x7f, 0xdf, 0xed, 0x0d, 0x10, 0x33, 0xba,
	0x5e, 0x23, 0x80, 0xfe, 0x78, 0x76, 0xfe, 0xed, 0xae, 0x17, 0x1f, 0x0c, 0x5a, 0xb5, 0x36, 0xee,
	0xd7, 0x79, 0x00, 0xd9, 0xcf, 0xc5, 0xa8, 0x73, 0x58, 0x8f, 0x8f, 0x03, 0x14, 0xd5, 0x1a, 0xa8,
	0xed, 0x24, 0xfa, 0xd4, 0x96, 0x7b, 0xc4, 0x6c, 0x19, 0x13, 0xda, 0xe2, 0xfa, 0xf6, 0x63, 0x0d,
	0x16, 0xd8, 0xf6, 0x3f, 0x43, 0x5e, 0xf7, 0x20, 0x76, 0x5c, 0xbf, 0x8b, 0xcc, 0x06, 0x4c, 0x6f,
	0xe3, 0x47, 0x28, 0x64, 0x08, 0xc6, 0x36, 0xcf, 0x94, 0x89, 0x95, 0x7b, 0x41, 0x80, 0xc2, 0x09,
	0x01, 0x33, 0x65, 0x73, 0x09, 0xf2, 0x6c, 0x6b, 0x14, 0xab, 0xe1, 0xf0, 0x91, 0xfd, 0xb9, 0xba,
	0xf1, 0x3d, 0xb7, 0xd5, 0x43, 0xe6, 0x06, 0xcc, 0x48, 0x38, 0x04, 0xa7, 0xdf, 0x14, 0xac, 0xca,
	0x20, 0xe5, 0xb4, 0x52, 0x94, 0xec, 0x1f, 0x34, 0x28, 0x6d, 0x63, 0xbf, 0x7b, 0x5a, 0x2c, 0xd7,
	0x21, 0xe7, 0xb8, 0xf1, 0xa4, 0x71, 0xa4, 0xba, 0xe6, 0x87, 0x50, 0x96, 0xf6, 0x4d, 0xa1, 0x95,
	0x57, 0x97, 0x12, 0xf6, 0xfb, 0xb1, 0xf4, 0x55, 0xe4, 0x90, 0x0c, 0xd4, 0x82, 0xc2, 0x4e, 0x88,
	0xbb, 0xa1, 0xdb, 0xb7, 0x72, 0x74, 0x67, 0x62, 0x68, 0xef, 0xc1, 0x5c, 0xa2, 0xce, 0xa2, 0xb9,
	0x28, 0x47, 0xd3, 0x10, 0xd1, 0x59, 0x94, 0xa3, 0x63, 0xbc, 0xc8, 0xdb, 0x8e, 0x64, 0x95, 0xed,
	0xe0, 0xa3, 0x91, 0xae, 0xce, 0x42, 0x38, 0xdd, 0xcf, 0x37, 0x60, 0x7e, 0x37, 0x0e, 0x3d, 0xbf,
	0x7b, 0x66, 0xe6, 0x2c, 0xc2, 0xb4, 0x94, 0x36, 0x0e, 0x1b, 0xd8, 0x1f, 0xc3, 0xec, 0x16, 0x92,
	0x53, 0xae, 0x22, 0x25, 0x18, 0xc3, 0x39, 0x4c, 0x98, 0x8a, 0x94, 0x30, 0x3a, 0xff, 0x26, 0x12,
	0xe0, 0x01, 0xcc, 0x91, 0x58, 0x9f, 0xb9, 0x85, 0x4a, 0x2a, 0x79, 0x4f, 0xb3, 0x6d, 0xa4, 0x6c,
	0x3f, 0xd6, 0x60, 0x76, 0x03, 0xfb, 0x1d, 0x2f, 0xf6, 0xb0, 0x4f, 0x4b, 0xee, 0x75, 0x28, 0x30,
	0x0e, 0x0a, 0x7f, 0x59, 0x2a, 0x35, 0x87, 0xdb, 0xe0, 0x1e, 0x13, 0xd3, 0xcd, 0x55, 0x12, 0x44,
	0xbf, 0x2b, 0x4a, 0x6d, 0xe2, 0x67, 0x75, 0xf3, 0x5c, 0x8b, 0x4d, 0x25, 0xab, 0x31, 0x07, 0x67,
	0xca, 0x6b, 0xda, 0xef, 0x62, 0x35, 0x3e, 0xdd, 0xfe, 0x49, 0x87, 0x12, 0x29, 0xb5, 0xac, 0xaa,
	0xa6, 0xab, 0xa3, 0x84, 0x42, 0x9f, 0x10, 0x85, 0x31, 0x11, 0x8a, 0xdc, 0x58, 0x28, 0xcc, 0x0f,
	0xa0, 0xbc, 0x17, 0xba, 0x7e, 0xb4, 0x8f, 0xc2, 0x2d, 0x84, 0xac, 0x69, 0x9a, 0x64, 0xaf, 0x0b,
	0x6d, 0x85, 0x3f, 0x22, 0xc7, 0xa4, 0xf9, 0xe6, 0x7b, 0xe4, 0x88, 0xe0, 0xd1, 0x8b, 0xac, 0xbc,
	0xaa, 0xad, 0xc4, 0x95, 0x6b, 0x4b, 0xd3, 0xed, 0x4d, 0x78, 0x8d, 0x91, 0x1d, 0x75, 0xc4, 0xb9,
	0x57, 0x81, 0x22, 0x39, 0x7e, 0x8f, 0x9b, 0x0d, 0x16, 0xfd, 0x92, 0x93, 0x8c, 0xa5, 0xbc, 0x63,
	0x34, 0x17, 0x79, 0xf7, 0x8d, 0x06, 0x65, 0x06, 0x87, 0x91, 0x53, 0xd4, 0x1e, 0xed, 0x3f, 0xd4,
	0x1e, 0x4e, 0x70, 0x7d, 0x44, 0x8e, 0x19, 0x52, 0x8e, 0x9d, 0x51, 0x63, 0x7e, 0xd6, 0xa0, 0xcc,
	0x42, 0xfa, 0x2a, 0x77, 0x75, 0x73, 0x54, 0x8d, 0x1c, 0x59, 0xcb, 0x27, 0x28, 0x93, 0xbf, 0x69,
	0x00, 0xc3, 0xa6, 0x24, 0x43, 0xf1, 0xb5, 0x34, 0xc5, 0xcf, 0xa9, 0xeb, 0x8e, 0x64, 0xf7, 0x45,
	0x95, 0xdd, 0x0b, 0x32, 0xbb, 0x47, 0x10, 0x7b, 0x2d, 0x4d, 0xec, 0x73, 0x2a, 0xb1, 0x47, 0x72,
	0x7a, 0x39, 0xcb, 0x69, 0x43, 0xa1, 0xad, 0xfd, 0x85, 0x0e, 0xf3, 0xe9, 0x36, 0x29, 0x83, 0xcf,
	0x86, 0x99, 0x24, 0xbf, 0x1d, 0xb4, 0xcf, 0xdd, 0xae, 0xc8, 0x64, 0x1f, 0x18, 0xe3, 0xfb, 0x20,
	0x37, 0xae, 0x0f, 0xa6, 0x27, 0xf5, 0x41, 0x3e, 0xeb, 0x83, 0x5f, 0x34, 0xd9, 0x07, 0xd4, 0x48,
	0x24, 0xe3, 0xd1, 0xc6, 0xc7, 0xa3, 0x8f, 0x8b, 0xc7, 0x98, 0x14, 0x4f, 0x2e, 0x8b, 0xe7, 0x7b,
	0x03, 0x72, 0x04, 0x0f, 0x99, 0x7a, 0x07, 0x77, 0xd0, 0x7d, 0x14, 0x46, 0x1e, 0x16, 0x7d, 0xae,
	0x2c, 0xe2, 0x91, 0xd6, 0x93, 0x48, 0x5f, 0x4d, 0x47, 0x71, 0x49, 0x45, 0x7d, 0x0b, 0x1d, 0xd3,
	0x74, 0x4f, 0x03, 0xbf, 0xa4, 0x06, 0x72, 0x51, 0x06, 0x9e, 0xd2, 0xe1, 0xd8, 0xaf, 0xa6, 0x63,
	0xb9, 0xa4, 0x62, 0x4f, 0xaf, 0x24, 0xe0, 0x57, 0x49, 0x9d, 0xc5, 0x87, 0x2d, 0x8c, 0x0f, 0x9b,
	0x0d, 0x1a, 0xcd, 0x92, 0x23, 0x49, 0x48, 0x6d, 0xdc, 0x45, 0x7e, 0x07, 0x85, 0x56, 0x81, 0xd5,
	0x46, 0x36, 0x32, 0x2f, 0xc0, 0xec, 0xdd, 0x47, 0x3e, 0x0a, 0x1d, 0xd4, 0xf6, 0x02, 0xd4, 0x6c,
	0x58, 0x45, 0xfa, 0x59, 0x15, 0x12, 0xa6, 0x53, 0xc1, 0x5e, 0xe8, 0x76, 0xc8, 0xa4, 0x12, 0x63,
	0xba, 0x2c, 0x23, 0x95, 0x99, 0xfc, 0xa5, 0x65, 0x06, 0x96, 0xb5, 0x95, 0xa2, 0x93, 0x8c, 0xc9,
	0xee, 0xb6, 0xdd, 0x28, 0xbe, 0x17, 0x74, 0x48, 0x85, 0x2b, 0xd3, 0xd8, 0x48, 0x92, 0x74, 0xf0,
	0x66, 0xb2, 0xc1, 0x3b, 0x80, 0x39, 0xd5, 0xd5, 0x23, 0x5a, 0x8c, 0x86, 0xd2, 0xe5, 0x8c, 0xdf,
	0x2b, 0xb3, 0x86, 0xe3, 0x2a, 0xcc, 0xc8, 0xe1, 0x79, 0x51, 0x37, 0x65, 0x08, 0xbd, 0xeb, 0x30,
	0xa7, 0x86, 0xe8, 0xa5, 0xfb, 0xb0, 0x2e, 0xcc, 0x31, 0x27, 0x26, 0xcd, 0xc2, 0x15, 0xa9, 0x73,
	0xa0, 0xfa, 0x52, 0xd2, 0x24, 0x1f, 0x38, 0x05, 0xa4, 0x1e, 0x43, 0x25, 0x81, 0x9e, 0x26, 0x81,
	0xfd, 0xa5, 0x06, 0xe6, 0x36, 0x6e, 0x1f, 0xa2, 0x0e, 0xb9, 0x8c, 0x35, 0x50, 0xd4, 0x0e, 0xbd,
	0x16, 0xca, 0xd4, 0xb5, 0x36, 0xe4, 0x6f, 0xf6, 0xf9, 0x6d, 0x8f, 0xb5, 0xfe, 0xcc, 0x5f, 0x35,
	0x72, 0x29, 0xae, 0xf1, 0x4b, 0x31, 0xbd, 0xdb, 0xae, 0x5f, 0x22, 0x5b, 0xf8, 0xee, 0xcf, 0xf3,
	0x2b, 0x2f, 0xe1, 0x63, 0xa2, 0x10, 0x39, 0xdc, 0xb4, 0xfd, 0x95, 0x06, 0xb3, 0xbb, 0x07, 0x38,
	0x8c, 0x91, 0xcf, 0x68, 0x96, 0xd9, 0xc6, 0x0b, 0xd0, 0x90, 0xfb, 0xe5, 0x1d, 0xb7, 0x2f, 0xce,
	0x5b, 0xfa, 0x9f, 0x10, 0x89, 0xc1, 0x0a, 0x48, 0x07, 0xc1, 0xcf, 0x2b, 0x59, 0x24, 0x25, 0xc2,
	0xb4, 0x9c, 0x08, 0xf6, 0x3f, 0x3a, 0x94, 0x36, 0x8f, 0x50, 0x7b, 0x40, 0x67, 0x8d, 0x5f, 0x22,
	0x2a, 0x50, 0x4c, 0x72, 0x88, 0xed, 0x28, 0x19, 0xa7, 0x90, 0xe4, 0x32, 0x48, 0x0e, 0xd9, 0x3d,
	0x9a, 0x06, 0x51, 0xe4, 0xfd, 0xff, 0xea, 0x74, 0xc9, 0xbc, 0xb9, 0xca, 0xce, 0x6c, 0xbe, 0x58,
	0x9e, 0x2e, 0x36, 0x23, 0x93, 0x4b, 0x34, 0x62, 0xc3, 0x59, 0xc4, 0x1d, 0xeb, 0x3d, 0xdc, 0x3e,
	0xfc, 0x84, 0xb5, 0x57, 0x05, 0x96, 0x9f, 0x92, 0x48, 0x72, 0x6b, 0x51, 0xa9, 0x2f, 0x6f, 0x41,
	0x69, 0x03, 0xf7, 0x83, 0x1e, 0x8a, 0x51, 0x87, 0x96, 0x8d, 0xa2, 0x33, 0x14, 0xd8, 0xdf, 0xea,
	0x50, 0x14, 0x7e, 0x98, 0xc0, 0xe7, 0x93, 0x31, 0xc0, 0x82, 0x82, 0x58, 0x83, 0x51, 0x40, 0x0c,
	0xc9, 0x66, 0x1b, 0xe8, 0x21, 0xea, 0x61, 0x72, 0xa5, 0x63, 0x35, 0x74, 0x28, 0xa0, 0x57, 0x40,
	0x32, 0xe0, 0xf0, 0xd9, 0x80, 0x94, 0xc6, 0xdd, 0x41, 0x10, 0xe0, 0x30, 0xde, 0xec, 0xbb, 0x5e,
	0x8f, 0xc3, 0x57, 0x64, 0x64, 0xce, 0x06, 0x8e, 0xe2, 0x1d, 0x14, 0x52, 0x97, 0x51, 0x3f, 0x18,
	0x8e, 0x22, 0x93, 0x1c, 0x08, 0x0a, 0x2f, 0xff, 0x36, 0x20, 0xcf, 0x13, 0x64, 0x7c, 0x07, 0xa9,
	0xc4, 0x33, 0x4e, 0x4d, 0xa1, 0x9c, 0xe4, 0xc0, 0x6b, 0x23, 0xc8, 0xb8, 0x20, 0x3f, 0x68, 0xc9,
	0xc5, 0x47, 0x26, 0xd6, 0xb5, 0x11, 0xc4, 0x3a, 0xb5, 0x6a, 0xc9, 0xec, 0x5a, 0x83, 0x02, 0x7f,
	0x52, 0xa3, 0xae, 0x95, 0xce, 0x7b, 0xe9, 0xa5, 0x4d, 0x1c, 0x78, 0x5c, 0x64, 0x5e, 0x83, 0x82,
	0x78, 0xf6, 0x2a, 0xd2, 0xa5, 0xde, 0x10, 0x4a, 0xa9, 0x2b, 0x83, 0x50, 0x14, 0x37, 0x88, 0x14,
	0x41, 0x4a, 0x59, 0x82, 0x5c, 0x80, 0x59, 0x1a, 0x93, 0xa6, 0x1f, 0xa3, 0xf0, 0xa1, 0xdb, 0xa3,
	0x11, 0x31, 0x1c, 0x55, 0x28, 0x05, 0xac, 0xac, 0x30, 0xbe, 0x02, 0xc5, 0x86, 0x17, 0x91, 0x63,
	0xaf, 0x43, 0x0f, 0xb2, 0xa2, 0x93, 0x8c, 0x09, 0xc1, 0x36, 0x8f, 0xe2, 0xd0, 0x6d, 0xfa, 0xfb,
	0xd8, 0x9a, 0x65, 0x04, 0x4b, 0x04, 0xf6, 0x89, 0x01, 0xd3, 0xf4, 0x20, 0x98, 0x20, 0xd2, 0x6a,
	0xd4, 0x8c, 0x97, 0x8f, 0xda, 0xfb, 0x4a, 0xd4, 0x72, 0x6a, 0xcf, 0xa1, 0x1e, 0x4b, 0x23, 0x42,
	0xd7, 0x57, 0x9f, 0x3f, 0x5f, 0x41, 0xe9, 0x52, 0x5e, 0x4c, 0xdf, 0x55, 0x5f, 0x4c, 0x4f, 0x2f,
	0x5e, 0xca, 0x5b, 0xa9, 0xe2, 0xf5, 0x42, 0xca, 0xeb, 0x67, 0x55, 0xae, 0xad, 0x41, 0x6f, 0xcb,
	0xeb, 0xf5, 0x50, 0xc8, 0x59, 0x32, 0x14, 0x28, 0x51, 0x86, 0x6c, 0x94, 0x87, 0x35, 0xaf, 0x9c,
	0xaa, 0x79, 0xeb, 0x5b, 0x4f, 0x9e, 0x57, 0xb5, 0xa7, 0xcf, 0xab, 0xda, 0x5f, 0xcf, 0xab, 0xda,
	0xd7, 0x27, 0xd5, 0xa9, 0xa7, 0x27, 0xd5, 0xa9, 0xdf, 0x4f, 0xaa, 0x53, 0x0f, 0xde, 0x91, 0x9c,
	0xb2, 0x43, 0x21, 0x5d, 0x8c, 0x51, 0xfb, 0x80, 0x3f, 0x5f, 0xd7, 0x8f, 0xc4, 0x1f, 0xea, 0x9e,
	0x56, 0x9e, 0x3e, 0x48, 0xaf, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x80, 0x05, 0x79, 0x84, 0xe5,
	0x16, 0x00, 0x00,
}

func (m *EntriesList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemModifyOutputs) > 0 {
		for iNdEx := len(m.ItemModifyOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemModifyOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ItemOutputs) > 0 {
		for iNdEx := len(m.ItemOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CoinOutputs) > 0 {
		for iNdEx := len(m.CoinOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CoinInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CoinOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Count) > 0 {
		i -= len(m.Count)
		copy(dAtA[i:], m.Count)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Count)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxValue.Size()
		i -= size
		if _, err := m.MaxValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinValue.Size()
		i -= size
		if _, err := m.MinValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleWeightRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleWeightRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleWeightRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Upper.Size()
		i -= size
		if _, err := m.Upper.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Lower.Size()
		i -= size
		if _, err := m.Lower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DoubleWeightTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleWeightTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleWeightTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for iNdEx := len(m.WeightRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeightRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LongParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.WeightTable.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IntWeightRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntWeightRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntWeightRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Upper != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Upper))
		i--
		dAtA[i] = 0x10
	}
	if m.Lower != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Lower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntWeightTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntWeightTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntWeightTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for iNdEx := len(m.WeightRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeightRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.MaxValue))
		i--
		dAtA[i] = 0x10
	}
	if m.MinValue != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.MinValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LongInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.MaxValue))
		i--
		dAtA[i] = 0x18
	}
	if m.MinValue != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.MinValue))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ItemInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Conditions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.TransferFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WeightedOutputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedOutputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedOutputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EntryIDs) > 0 {
		for iNdEx := len(m.EntryIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EntryIDs[iNdEx])
			copy(dAtA[i:], m.EntryIDs[iNdEx])
			i = encodeVarintPylons(dAtA, i, uint64(len(m.EntryIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DoubleParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.WeightTable.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ItemOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemModifyOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemModifyOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemModifyOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ItemInputRef) > 0 {
		i -= len(m.ItemInputRef)
		copy(dAtA[i:], m.ItemInputRef)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ItemInputRef)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemModifyParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemModifyParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemModifyParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x60
	}
	if m.LastUpdate != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x58
	}
	if m.Tradable {
		i--
		if m.Tradable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.OwnerTradeID) > 0 {
		i -= len(m.OwnerTradeID)
		copy(dAtA[i:], m.OwnerTradeID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.OwnerTradeID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OwnerRecipeID) > 0 {
		i -= len(m.OwnerRecipeID)
		copy(dAtA[i:], m.OwnerRecipeID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.OwnerRecipeID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LongKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradeItemInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeItemInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeItemInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ItemInput.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockedCoinDescribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockedCoinDescribe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockedCoinDescribe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShortenRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShortenRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShortenRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockHeight != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinInputs) > 0 {
		for iNdEx := len(m.CoinInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cookbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cookbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cookbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x52
	}
	if m.CostPerBlock != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.CostPerBlock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.SupportEmail) > 0 {
		i -= len(m.SupportEmail)
		copy(dAtA[i:], m.SupportEmail)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.SupportEmail)))
		i--
		dAtA[i] = 0x42
	}
	if m.Level != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Recipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtraInfo) > 0 {
		i -= len(m.ExtraInfo)
		copy(dAtA[i:], m.ExtraInfo)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ExtraInfo)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BlockInterval != 0 {
		i = encodeVarintPylons(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPylons(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinInputs) > 0 {
		for iNdEx := len(m.CoinInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.FulFiller) > 0 {
		i -= len(m.FulFiller)
		copy(dAtA[i:], m.FulFiller)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.FulFiller)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExtraInfo) > 0 {
		i -= len(m.ExtraInfo)
		copy(dAtA[i:], m.ExtraInfo)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ExtraInfo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ItemOutputs) > 0 {
		for iNdEx := len(m.ItemOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CoinOutputs) > 0 {
		for iNdEx := len(m.CoinOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ItemInputs) > 0 {
		for iNdEx := len(m.ItemInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CoinInputs) > 0 {
		for iNdEx := len(m.CoinInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPylons(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeVersion) > 0 {
		i -= len(m.NodeVersion)
		copy(dAtA[i:], m.NodeVersion)
		i = encodeVarintPylons(dAtA, i, uint64(len(m.NodeVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPylons(dAtA []byte, offset int, v uint64) int {
	offset -= sovPylons(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EntriesList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CoinOutputs) > 0 {
		for _, e := range m.CoinOutputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemOutputs) > 0 {
		for _, e := range m.ItemOutputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemModifyOutputs) > 0 {
		for _, e := range m.ItemModifyOutputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	return n
}

func (m *CoinInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovPylons(uint64(m.Count))
	}
	return n
}

func (m *CoinOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Count)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *DoubleInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = m.MinValue.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = m.MaxValue.Size()
	n += 1 + l + sovPylons(uint64(l))
	return n
}

func (m *DoubleWeightRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Lower.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = m.Upper.Size()
	n += 1 + l + sovPylons(uint64(l))
	if m.Weight != 0 {
		n += 1 + sovPylons(uint64(m.Weight))
	}
	return n
}

func (m *DoubleWeightTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for _, e := range m.WeightRanges {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	return n
}

func (m *LongParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = m.Rate.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = m.WeightTable.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *IntWeightRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovPylons(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovPylons(uint64(m.Upper))
	}
	if m.Weight != 0 {
		n += 1 + sovPylons(uint64(m.Weight))
	}
	return n
}

func (m *IntWeightTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for _, e := range m.WeightRanges {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	return n
}

func (m *StringInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *FeeInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinValue != 0 {
		n += 1 + sovPylons(uint64(m.MinValue))
	}
	if m.MaxValue != 0 {
		n += 1 + sovPylons(uint64(m.MaxValue))
	}
	return n
}

func (m *LongInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.MinValue != 0 {
		n += 1 + sovPylons(uint64(m.MinValue))
	}
	if m.MaxValue != 0 {
		n += 1 + sovPylons(uint64(m.MaxValue))
	}
	return n
}

func (m *ConditionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	return n
}

func (m *ItemInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = m.TransferFee.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = m.Conditions.Size()
	n += 1 + l + sovPylons(uint64(l))
	return n
}

func (m *WeightedOutputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EntryIDs) > 0 {
		for _, s := range m.EntryIDs {
			l = len(s)
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *StringParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rate.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *DoubleParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rate.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = m.WeightTable.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *ItemOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if m.TransferFee != 0 {
		n += 1 + sovPylons(uint64(m.TransferFee))
	}
	return n
}

func (m *ItemModifyOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ItemInputRef)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if m.TransferFee != 0 {
		n += 1 + sovPylons(uint64(m.TransferFee))
	}
	return n
}

func (m *ItemModifyParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if m.TransferFee != 0 {
		n += 1 + sovPylons(uint64(m.TransferFee))
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.OwnerRecipeID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.OwnerTradeID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Tradable {
		n += 2
	}
	if m.LastUpdate != 0 {
		n += 1 + sovPylons(uint64(m.LastUpdate))
	}
	if m.TransferFee != 0 {
		n += 1 + sovPylons(uint64(m.TransferFee))
	}
	return n
}

func (m *DoubleKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovPylons(uint64(l))
	return n
}

func (m *LongKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovPylons(uint64(m.Value))
	}
	return n
}

func (m *StringKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *TradeItemInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ItemInput.Size()
	n += 1 + l + sovPylons(uint64(l))
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *LockedCoinDescribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	return n
}

func (m *ShortenRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.CoinInputs) > 0 {
		for _, e := range m.CoinInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if m.BlockHeight != 0 {
		n += 1 + sovPylons(uint64(m.BlockHeight))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Completed {
		n += 2
	}
	return n
}

func (m *Cookbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovPylons(uint64(m.Level))
	}
	l = len(m.SupportEmail)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.CostPerBlock != 0 {
		n += 1 + sovPylons(uint64(m.CostPerBlock))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *Recipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.CoinInputs) > 0 {
		for _, e := range m.CoinInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = m.Entries.Size()
	n += 1 + l + sovPylons(uint64(l))
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovPylons(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	l = len(m.ExtraInfo)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if len(m.CoinInputs) > 0 {
		for _, e := range m.CoinInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemInputs) > 0 {
		for _, e := range m.ItemInputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.CoinOutputs) > 0 {
		for _, e := range m.CoinOutputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	if len(m.ItemOutputs) > 0 {
		for _, e := range m.ItemOutputs {
			l = e.Size()
			n += 1 + l + sovPylons(uint64(l))
		}
	}
	l = len(m.ExtraInfo)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	l = len(m.FulFiller)
	if l > 0 {
		n += 1 + l + sovPylons(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if m.Completed {
		n += 2
	}
	return n
}

func sovPylons(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPylons(x uint64) (n int) {
	return sovPylons(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EntriesList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinOutputs = append(m.CoinOutputs, CoinOutput{})
			if err := m.CoinOutputs[len(m.CoinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemOutputs = append(m.ItemOutputs, ItemOutput{})
			if err := m.ItemOutputs[len(m.ItemOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemModifyOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemModifyOutputs = append(m.ItemModifyOutputs, ItemModifyOutput{})
			if err := m.ItemModifyOutputs[len(m.ItemModifyOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleWeightRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleWeightRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleWeightRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Upper.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleWeightTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleWeightTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleWeightTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightRanges = append(m.WeightRanges, DoubleWeightRange{})
			if err := m.WeightRanges[len(m.WeightRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WeightTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntWeightRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntWeightRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntWeightRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntWeightTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntWeightTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntWeightTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightRanges = append(m.WeightRanges, IntWeightRange{})
			if err := m.WeightRanges[len(m.WeightRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			m.MinValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			m.MaxValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			m.MinValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			m.MaxValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleInputParam{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongInputParam{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringInputParam{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleInputParam{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongInputParam{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringInputParam{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransferFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Conditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedOutputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedOutputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedOutputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryIDs = append(m.EntryIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WeightTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleParam{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongParam{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringParam{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemModifyOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemModifyOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemModifyOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleParam{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongParam{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringParam{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemModifyParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemModifyParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemModifyParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleParam{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongParam{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringParam{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, DoubleKeyValue{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, LongKeyValue{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, StringKeyValue{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerRecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerRecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerTradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerTradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tradable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tradable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeItemInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeItemInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeItemInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ItemInput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockedCoinDescribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockedCoinDescribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockedCoinDescribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShortenRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShortenRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShortenRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinInputs = append(m.CoinInputs, types.Coin{})
			if err := m.CoinInputs[len(m.CoinInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, Item{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cookbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cookbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cookbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostPerBlock", wireType)
			}
			m.CostPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinInputs = append(m.CoinInputs, CoinInput{})
			if err := m.CoinInputs[len(m.CoinInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, ItemInput{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, WeightedOutputs{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinInputs = append(m.CoinInputs, CoinInput{})
			if err := m.CoinInputs[len(m.CoinInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputs = append(m.ItemInputs, TradeItemInput{})
			if err := m.ItemInputs[len(m.ItemInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinOutputs = append(m.CoinOutputs, types.Coin{})
			if err := m.CoinOutputs[len(m.CoinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemOutputs = append(m.ItemOutputs, Item{})
			if err := m.ItemOutputs[len(m.ItemOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FulFiller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPylons
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPylons
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FulFiller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPylons(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPylons
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPylons(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPylons
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPylons
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPylons
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPylons
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPylons
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPylons        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPylons          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPylons = fmt.Errorf("proto: unexpected end of group")
)
