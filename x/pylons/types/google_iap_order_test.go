package types

import (

	// #nosec

	fmt "fmt"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestValidateGoogleIAPSignatureSelfSigned(t *testing.T) {

	privateKey := GenerateRSAKey()
	googleInAppPurchasePubKey := GenerateRSAPublicKey(privateKey)
	// Message is generated by IAP app
	message := "{\"orderId\":\"GPA.3394-4112-7048-14805\",\"packageName\":\"tech.pylons.wallet\",\"productId\":\"free_pylons\",\"purchaseTime\":1653891466961,\"purchaseState\":0,\"purchaseToken\":\"eafhleeolclclafkfmmcidoj.AO-J1OxuhZCjvZC7qmYxXCQFDAsrQ2FAot8PHgd9Gt0Ag_-U9ZCzao6EdkDBhxWGfQFqwV9PZNx5sW-WMrv5KfYS1g4K-mhDAA\",\"acknowledged\":false}"
	digest := GenerateBase64Digest(message)
	encodedBase64Digest := toBase64([]byte(message))
	signature, err := SignPKCS1v15(privateKey, digest)
	if err != nil {
		t.Error(fmt.Printf("rsa.SignPKCS1v15 error: %v\n", err))
		t.Fail()
	}
	signaturebase64Encoded := toBase64(signature)
	tests := []struct {
		name       string
		coinIssuer CoinIssuer
		msg        *MsgGoogleInAppPurchaseGetCoins
		wantErr    bool
	}{
		{"valid purchase", CoinIssuer{GoogleInAppPurchasePubKey: googleInAppPurchasePubKey}, &MsgGoogleInAppPurchaseGetCoins{ReceiptDataBase64: encodedBase64Digest, Signature: signaturebase64Encoded}, false},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.wantErr, ValidateGoogleIAPSignature(tt.msg, tt.coinIssuer) != nil)
		})
	}
}

func TestValidateGoogleIAPPublicSignature(t *testing.T) {

	// Message is generated by IAP app
	message := `{"orderId":"GPA.3308-1418-1838-26432","packageName":"tech.pylons.wallet","productId":"pylons_5","purchaseTime":1655206339882,"purchaseState":0,"purchaseToken":"kecoklhikhaepfedhadhiebp.AO-J1Ox-sOzcaUmNMBWuXE7pQklGCJblzObbV7kuPyPFegQeILaXuhf-NuV0H2DZEWIAvETdX3OEgFEXsIlNsx-uZBDaLJF8oA","acknowledged":false}`
	encodedBase64Digest := toBase64([]byte(message))

	// Signature is generated by google
	validSignature := "C4qPmpyiGhmJZraiftEEqYT+sfQ5XRkG3DaGAR24A/mtZyKi2Ix0qR7RVYJVjpMkn2zZcZWNs23e52G8viAXQHhlleEDSCgNgIf23AwuM+4Lu2lzJCrftYxVLAksviUMtPaj/XGOx1UcLOwtK4XDBDlkgYOeCT9vZGZ88suguINR/OpNe5/j2Pzkx5wAuKUjirXonOZpvu+XrXnf42Eb7IepgbiBWa1PPJttJBDKSxbYC56D6+InRmT1Vyhpp8tWsM4r4riAB9goHR2EtD9WjEQxP9bMyp/e64C5i2d9lMrHArmOPIZoIaBgPN6CJ/KoNqVJe3SyBaW3xqMO3eouww=="
	msg := &MsgGoogleInAppPurchaseGetCoins{ReceiptDataBase64: encodedBase64Digest, Signature: validSignature}
	googleInAppPurchasePubKey := SampleGoogleInAppPurchasePubKey
	coinIssuer := CoinIssuer{GoogleInAppPurchasePubKey: googleInAppPurchasePubKey}

	tests := []struct {
		name       string
		coinIssuer CoinIssuer
		msg        *MsgGoogleInAppPurchaseGetCoins
		wantErr    bool
	}{
		{"valid purchase", coinIssuer, msg, false},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.wantErr, ValidateGoogleIAPSignature(msg, tt.coinIssuer) != nil)
		})
	}
}

func TestValidateGoogleIAPSignature(t *testing.T) {

	// Signature is generated by google
	validSignature := "O90FTzVlKiwRMasg0tgEF65tXoQi7BKOoA8K+2i1SuC0Mbi49Tw7JJAK6bHVXMqGn/urkANCJl1+Zu3vabp91SPLpT1hlVwzAC2NIRa5qs7D7DgAZiaRhqqP+01LNc3DKzxGWVThzT6Cq4PB0h2LyYDlZZBfGFXH9LAXd4e+lNTgewAs1zmBzWBDdFO1G8S7xxB373MgW9V9/rKZH1odyDaMBhbvhMgunmxdtmO6/MOuxkdg2FjvUxXzPTAmnUvoLEM2771caP5JAYxQNeejj2Te1QCTWZ1F66MIggJLEBBqq7sIafGRJ4zKHtpJyhR8iSKatzXcHrXMqUSqTs/W9Q=="

	// Receipt is generated by google
	validReceipt64 := "eyJvcmRlcklkIjoiR1BBLjMzMDYtNzU5MS0wMzk4LTgxMDY1IiwicGFja2FnZU5hbWUiOiJ0ZWNoLnB5bG9ucy53YWxsZXQiLCJwcm9kdWN0SWQiOiJmcmVlX3B5bG9ucyIsInB1cmNoYXNlVGltZSI6MTY1NDYxNTc3Nzc5OSwicHVyY2hhc2VTdGF0ZSI6MCwicHVyY2hhc2VUb2tlbiI6ImNiZWphYWhlaGFhbGlwcGJhbGtwYmRsaS5BTy1KMU95RU9CN205WnpsRnFfQ2hKcHJLTDZUeklmbnlyZ2UwcmtseVQydFFHZHk3RVRrNEYteHhtQ1RCWXlHVU15cVpZMFRpWlZxZUt2Q2M3WTVlTlFET2pnSUxUa292dyIsImFja25vd2xlZGdlZCI6ZmFsc2V9"

	msg := &MsgGoogleInAppPurchaseGetCoins{ReceiptDataBase64: validReceipt64, Signature: validSignature}
	coinIssuer := CoinIssuer{GoogleInAppPurchasePubKey: SampleGoogleInAppPurchasePubKey}
	err := ValidateGoogleIAPSignature(msg, coinIssuer)
	if err != nil {
		t.Fail()
	}

}
